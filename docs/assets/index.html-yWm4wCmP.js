import{_ as n,c as i,a,o as e}from"./app-D9na5qdx.js";const l="/docs/images/u=128634482,3004766485&fm=26&gp=0.jpg",p="/docs/images/image-20210223151838104.png",d="/docs/images/image-20231003081944836.png",t="/docs/images/threadpoolexecutor.jpg",r="/docs/images/image-20200630181602123.png",c="/docs/images/image-20231003081954830.png",h="/docs/images/image-20200716083708939.png",k="/docs/images/image-20200716083953114.png",v="/docs/images/image-20200714164029991.png",u="/docs/images/image-20231003081920956.png",o="/docs/images/image-20231003081934377.png",g="/docs/images/image-20231003081853814.png",m="/docs/images/image-20231003081858204.png",b="/docs/images/image-20231003081733471.png",y="/docs/images/image-20231003081737647.png",A="/docs/images/image-20231003081741216.png",f="/docs/images/image-20231003081747028.png",D="/docs/images/image-20231003081751201.png",B="/docs/images/image-20231003081754493.png",E="/docs/images/image-20231003081758886.png",C="/docs/images/image-20231003081804285.png",S="/docs/images/image-20231003081809071.png",x="/docs/images/image-20231003081812439.png",T="/docs/images/image-20231003081818561.png",w="/docs/images/image-20231003081823000.png",_="/docs/images/image-20231003081829773.png",q="/docs/images/image-20231003081833573.png",j="/docs/images/image-20231003081836936.png",F="/docs/images/image-20200706155313157.png",P="/docs/images/image-20200706160910377.png",z={};function L(O,s){return e(),i("div",null,s[0]||(s[0]=[a('<p>请在此处补充摘要</p><p>JUC源码分析</p><ul><li>CAS和Unsafe</li><li>AQS</li><li>集合collection <ul><li>ConcurrentHashMap</li><li>CopyOnWriteArrayList和CopyOnWriteArraySet</li><li>ConcurrentSkipListMap和ConcurrentSkipListSet</li><li>ConcurrentLinkedQueue</li><li>ConcurrentLinkedDeque</li><li>LinkedTransferQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li></ul></li><li>队列 <ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li><li>DelayQueue</li><li>LinkedTransferQueue</li><li>LinkedBlockingDeque</li></ul></li><li>线程池 <ul><li>ThreadPoolExecutor</li><li>FutureTask</li><li>ScheduledThreadPoolExecutor</li><li>ForkJoinPool - 1</li><li>ForkJoinPool - 2</li></ul></li></ul><p>JUC锁</p><ul><li>ReetrantLock</li><li>ReentrantReadWriteLock</li><li>CountDownLatch</li><li>CyclicBarrier</li><li>Phaser</li><li>StampedLock</li></ul><p>集合</p><h1 id="并发编程" tabindex="-1"><a class="header-anchor" href="#并发编程"><span>并发编程</span></a></h1><blockquote><p>并发编程，侧重如何保证并发下的原子性，多线程</p><p>高并发,更多指的是可用性。缓存、异构、消息、集群、存储分片等等</p><p>java中使用的1对1的内核线程</p></blockquote><h2 id="_1-j-u-c" tabindex="-1"><a class="header-anchor" href="#_1-j-u-c"><span>1. J.U.C</span></a></h2><h3 id="_1-1-线程池" tabindex="-1"><a class="header-anchor" href="#_1-1-线程池"><span>1.1 线程池</span></a></h3><h4 id="_1-1-1-线程回顾" tabindex="-1"><a class="header-anchor" href="#_1-1-1-线程回顾"><span>1.1.1 线程回顾</span></a></h4><p>1）回顾线程创建方式</p><ul><li>继承Thread</li><li>实现Runnable(扩展性好)</li></ul><p>2）线程的状态</p><p><img src="'+l+`" alt="img"></p><ul><li>NEW：刚刚创建，没做任何操作</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Thread</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>RUNNABLE：调用run，可以执行，但不代表一定在执行（RUNNING,READY）</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">start</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>BLOCKED：抢不到锁</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> byte</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> byte</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Runnable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> run</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        synchronized</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">){</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> catch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InterruptedException </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">printStackTrace</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">start</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Thread</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Runnable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> run</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        synchronized</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">){</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">start</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>WAITING</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Thread</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Runnable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> run</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        LockSupport</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">park</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">start</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">500</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">LockSupport</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">unpark</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">500</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>TIMED_WAITING</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Thread</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> thread3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Runnable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> run</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> catch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InterruptedException </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">printStackTrace</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">start</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">500</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>TERMINATED</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//等待1s后再来看</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）线程池</p><blockquote><p>上面的单独的线程(野线程),业务中越来越多线程,是对资源的一种消耗。而且很乱,无法管控。</p><p>一个机器对创建线程的数量是有限制的，而不是无限制的创建线程。所以池化思想是很有必要的！</p></blockquote><p>​ 根据上面的状态，普通线程执行完，就会进入TERMINATED销毁掉，而线程池就是创建一个缓冲池存放线程，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等候下次任务来临，这使得线程池比手动创建线程有着更多的优势：</p><ul><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li><li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM</li><li>节省cpu切换线程的时间成本（需要保持当前执行线程的现场，并恢复要执行线程的现场）。</li><li>提供更强大的功能，延时定时线程池。<em>（Timer vs ScheduledThreadPoolExecutor）</em></li></ul><p>【扩展了解】：</p><p>在 32 位 Linux 系统里，一个进程的虚拟空间是 4G，内核分走了1G，<strong>留给用户用的只有 3G</strong>。那么假设创建一个线程需要占用 10M 虚拟内存，总共有 <code>3G</code> 虚拟内存可以使用。于是我们可以算出，最多可以创建差不多 <code>300</code> 个（3G/10M）左右的线程。</p><p>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</p><p>4）线程池体系（<em>查看：ScheduledThreadPoolExecutor，ForkJoinPool类图</em>）</p><p><img src="`+p+'" alt="image-20210223151838104"></p><p>说明：</p><ul><li>最常用的是ThreadPoolExecutor</li><li>调度用ScheduledThreadPoolExecutor</li><li>任务拆分合并用ForkJoinPool</li><li>Executors是工具类，协助你创建线程池的</li></ul><h4 id="_1-1-2-核心参数" tabindex="-1"><a class="header-anchor" href="#_1-1-2-核心参数"><span>1.1.2 核心参数</span></a></h4><p>Java 提供的线程池相关的工具类中，最核心的是 ThreadPoolExecutor，我们首先来看它的类体系及构造</p><p><img src="'+d+`" alt="image-20231003081944836"></p><p>核心构造：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> ThreadPoolExecutor</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> extends</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> AbstractExecutorService</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> RejectedExecutionHandler</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> defaultHandler</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> AbortPolicy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //核心的构造函数，其他构造函数都是调用该构造函数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">                              int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> maximumPoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">                              long</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> keepAliveTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                              TimeUnit </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">unit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                              BlockingQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Runnable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                              ThreadFactory </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">threadFactory</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                              RejectedExecutionHandler </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">handler</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">corePoolSize </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ||</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            maximumPoolSize </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ||</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            maximumPoolSize </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> corePoolSize </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">||</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            keepAliveTime </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            throw</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> IllegalArgumentException</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">workQueue </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ||</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> threadFactory </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ||</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> handler </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            throw</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> NullPointerException</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">maximumPoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> maximumPoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">keepAliveTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> unit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toNanos</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">keepAliveTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">threadFactory</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> threadFactory</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">        this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">handler</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> handler</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>线程池核心参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程池基本大小，核心线程数</td></tr><tr><td>maximumPoolSize</td><td>线程池最大线程数</td></tr><tr><td>keepAliveTime</td><td>线程空闲后的存活时间</td></tr><tr><td>TimeUnit unit</td><td>线程空闲后的存活时间单位</td></tr><tr><td>BlockingQueue workQueue</td><td>存放任务的阻塞队列</td></tr><tr><td>ThreadFactory threadFactory</td><td>创建线程的工厂</td></tr><tr><td>RejectedExecutionHandler handler</td><td>当阻塞队列和最大线程池都满了之后的饱和策略</td></tr></tbody></table><ul><li><strong>corePoolSize：核心线程数量</strong></li></ul><p>1：线程池刚创建时，线程数量为0，当每次执行<code>execute</code>添加新的任务时会在线程池创建一个新的线程，直到线程数量达到<code>corePoolSize</code>为止。</p><p>2：核心线程会一直存活，即使没有任务需要执行，当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理</p><p>3：设置<code>allowCoreThreadTimeout=true</code>（默认false）时，核心线程超时会关闭</p><ul><li><strong>workQueue：阻塞队列</strong></li></ul><p>1：当线程池正在运行的线程数量已经达到<code>corePoolSize</code>，那么再通过<code>execute</code>添加新的任务则会被加<code>workQueue</code>队列中，在队列中排队等待执行，而不会立即执行。</p><p>一般来说，这里的阻塞队列有以下几种选择：</p><p><code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>，<code>SynchronousQueue</code>;</p><ul><li><strong>maximumPoolSize：最大线程数</strong></li></ul><p>1：当池中的线程数<code>&gt;=corePoolSize</code>，且任务队列已满时。线程池会创建新线程来处理任务</p><p>2：当池中的线程数<code>=maximumPoolSize</code>，且任务队列已满时，线程池会拒绝处理任务而抛出异常</p><ul><li><strong>keepAliveTime：线程空闲时间</strong></li></ul><p>1：当线程空闲时间达到<code>keepAliveTime</code>时，线程会退出，直到线程数量<code>=corePoolSize</code></p><p>2：如果<code>allowCoreThreadTimeout=true</code>，则会直到线程数量=0</p><ul><li><strong>threadFactory：线程工厂，主要用来创建线程</strong></li><li><strong>rejectedExecutionHandler：任务拒绝处理器，两种情况会拒绝处理任务</strong></li></ul><p>1：当线程数已经达到<code>maxPoolSize</code>，且队列已满，会拒绝新任务</p><p>2：当线程池被调用<code>shutdown()</code>后，会等待线程池里的任务执行完毕，再<code>shutdown</code>。如果在调用<code>shutdown()</code>和线程池真正<code>shutdown</code>之间提交任务，会拒绝新任务</p><p>3：当拒绝处理任务时线程池会调用<code>rejectedExecutionHandler</code>来处理这个任务。如果没有设置默认是<code>AbortPolicy</code>，另外在<code>ThreadPoolExecutor</code>类有几个内部实现类来处理这类情况</p><p><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常。</p><p><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务</p><p><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常</p><p><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p><ul><li><a href="https://blog.csdn.net/riemann_/article/details/104704197" target="_blank" rel="noopener noreferrer">线程池中各个参数如何合理设置</a></li></ul><h4 id="_1-1-3-源码剖析" tabindex="-1"><a class="header-anchor" href="#_1-1-3-源码剖析"><span>1.1.3 源码剖析</span></a></h4><p><strong>execute详解</strong></p><p><code>ThreadPoolExecutor</code>的最基本使用方式就是通过<code>execute</code>方法提交一个<code>Runnable</code>任务，首先看图理解<code>execute</code>的执行逻辑</p><p><img src="`+t+'" alt="img"></p><p><img src="'+r+`" alt="image-20200630181602123"></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//任务提交阶段：Proceed in 3 steps: 3步走</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> execute</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Runnable command</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">command </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            throw</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> NullPointerException</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ctl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //判断工作数，如果小于coreSize，addWork，注意第二个参数core=true</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">workerCountOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">      if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">addWorker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">command</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">          return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">      c </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ctl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //否则，如果线程池还在运行，offer到队列</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">isRunning</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">offer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">command</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      //再检查一下状态</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">      int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> recheck</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ctl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      //如果线程池已经终止，直接移除任务，不再响应</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">      if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> isRunning</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">recheck</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;&amp;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> remove</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">command</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">          reject</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">command</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      //否则，如果没有可用线程的话（比如coreSize=0），创建一个空work</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        //该work创建时不会给指派任务（为null），但是会被放入works集合，进而从队列获取任务去执行</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">      else</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">workerCountOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">recheck</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">          addWorker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //队列也满，继续调addWork，但是注意，core=false，开启到maxSize的大门</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //超出max的话，addWork会返回false，进入reject</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  else</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">addWorker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">command</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">      reject</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">command</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//线程创建</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> boolean</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> addWorker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Runnable firstTask</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> boolean</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> core</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //第一步，计数判断，不符合条件打回false</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    retry</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">:</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (;;)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ctl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> rs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> runStateOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // Check if queue empty only if necessary.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (;;)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">            int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> wc</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> workerCountOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //判断线程数，注意这里！</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //也就说明线程池的线程数是不可能设置任意大的。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //最大29位（CAPACITY=29位二进制）</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //超出规定范围，返回false，表示不允许再开启新工作线程，创建worker失败！</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">wc </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> CAPACITY </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">||</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                wc </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;=</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">core </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">?</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> corePoolSize </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">:</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> maximumPoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">                return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">compareAndIncrementWorkerCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">                break</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> retry</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            c </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ctl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // Re-read ctl</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">runStateOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> !=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> rs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">                continue</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> retry</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            // else CAS failed due to workerCount change; retry inner loop</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //第二步，创建新work放入线程集合works（一个HashSet）</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> workerStarted</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> workerAdded</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    Worker</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> w</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        //符合条件，创建新的work并包装task</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        w </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Worker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">firstTask</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        final</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Thread</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> t</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> w</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">t </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">            final</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ReentrantLock</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> mainLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">mainLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //加锁，workers是一个hashset，这里要保障线程安全性</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            mainLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">   </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                        //...</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                    //在这里！！！</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                    workers</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">w</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                    </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                    //...                    </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                    workerAdded </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> finally</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                mainLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">unlock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">workerAdded</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                //注意，只要是成功add了新的work，那么将该新work立即启动，任务得到执行</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                t</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">start</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                workerStarted </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> finally</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> workerStarted</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">            addWorkerFailed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">w</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> workerStarted</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//任务获取与执行</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//在worker执行runWorker()的时候，不停循环，先查看自己有没有携带Task，如果有，执行</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">task </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ||</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">task </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getTask</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> !=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//如果没用，会调用getTask，从队列获取任务</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Runnable </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getTask</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> timedOut</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // Did the last poll() time out?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (;;)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ctl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> rs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> runStateOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> wc</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> workerCountOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // Are workers subject to culling? - 很形象，要不要乖乖的被“捕杀”？</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        //判断是不是要超时处理，重点！！！决定了当前线程要不要被释放</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> timed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> allowCoreThreadTimeOut </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">||</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> wc </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                //线程数超出max，并且上次循环中poll等待超时了，那么说明该线程已终止</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        //将线程队列数量原子性减</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ((</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">wc </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> maximumPoolSize </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">||</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">timed </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> timedOut</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">            &amp;&amp;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">wc </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ||</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">isEmpty</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //计数器做原子递减，递减成功后，返回null，for被中止</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">compareAndDecrementWorkerCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">c</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">                return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //递减失败，继续下一轮循环，直到成功</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            continue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //重点！！！</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //如果线程可被释放，那就poll，释放的时间为：keepAliveTime</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //否则，线程是不会被释放的，take一直被阻塞在这里，直到来了新任务继续工作</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            Runnable</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> r</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> timed </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">?</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">poll</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">keepAliveTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">NANOSECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> :</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">take</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">r </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">                return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> r</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            //到这里说明可被释放的线程等待超时，已经销毁，设置该标记，下次循环将线程数减少</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            timedOut </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> catch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InterruptedException </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">retry</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">            timedOut </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-1-4-executors" tabindex="-1"><a class="header-anchor" href="#_1-1-4-executors"><span>1.1.4 Executors</span></a></h4><p>以上构造函数比较多，为了方便使用，juc提供了一个Executors工具类，内部提供静态方法</p><p>1）newCachedThreadPool() ： 弹性线程数</p><p>2）newFixedThreadPool(int nThreads) ： 固定线程数</p><p>3）newSingleThreadExecutor() : 单一线程数</p><p>4）newScheduledThreadPool(int corePoolSize) ： 可调度，常用于定时</p><h4 id="_1-1-5-经典面试" tabindex="-1"><a class="header-anchor" href="#_1-1-5-经典面试"><span>1.1.5 经典面试</span></a></h4><p>1）线程池是如何保证线程不被销毁的呢？</p><p>答案：如果队列中没有任务时，核心线程会一直阻塞在获取任务的方法，直到返回任务。而任务执行完后，又会进入下一轮 work.runWork()中循环</p><p>验证：秘密就藏在核心源码里 ThreadPoolExecutor.getTask()</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//work.runWork():</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">task </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ||</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">task </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getTask</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> !=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//work.getTask():</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> timed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> allowCoreThreadTimeOut </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">||</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> wc </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> corePoolSize</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Runnable</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> r</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> timed </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">?</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">poll</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">keepAliveTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">NANOSECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> :</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    workQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">take</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）那么线程池中的线程会处于什么状态？</p><p>答案：RUNNABLE,WAITING</p><p>验证：起一个线程池，放置一个任务sleep，debug查看结束前后的状态</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//debug add watcher:</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">((</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> poolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">workers</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">iterator</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">().</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">().</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ThreadPoolExecutor</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> poolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newFixedThreadPool</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">poolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">execute</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Runnable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> run</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> catch</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InterruptedException </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">            e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">printStackTrace</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">});</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">ok</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）核心线程与非核心线程有区别吗？</p><p>答案：没有。被销毁的线程和创建的先后无关。即便是第一个被创建的核心线程，仍然有可能被销毁</p><p>验证：看源码，每个work在runWork()的时候去getTask()，在getTask内部，并没有针对性的区分当前work是否是核心线程或者类似的标记。只要判断works数量超出core，就会调用poll()，否则take()</p><h3 id="_1-2-fork-join" tabindex="-1"><a class="header-anchor" href="#_1-2-fork-join"><span>1.2 Fork/Join</span></a></h3><h4 id="_1-2-1-概念" tabindex="-1"><a class="header-anchor" href="#_1-2-1-概念"><span>1.2.1 概念</span></a></h4><p>​ ForkJoinPool是由JDK1.7后提供多线程并行执行任务的框架。可以理解为一种特殊的线程池。</p><p>​ 1.任务分割：Fork（分岔），先把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。</p><p>2.合并结果：join，分割后的子任务被多个线程执行后，再合并结果，得到最终的完整输出。</p><p><img src="`+c+'" alt="image-20231003081954830"></p><h4 id="_1-2-2-组成" tabindex="-1"><a class="header-anchor" href="#_1-2-2-组成"><span>1.2.2 组成</span></a></h4><ul><li><p><strong>ForkJoinTask</strong>：主要提供fork和join两个方法用于任务拆分与合并；一般用子类 RecursiveAction（无返回值的任务）和RecursiveTask（需要返回值）来实现compute方法。</p></li><li><p><strong>ForkJoinPool</strong>：调度ForkJoinTask的线程池；</p><p><img src="'+h+'" alt="image-20200716083708939"></p></li><li><p><strong>ForkJoinWorkerThread</strong>：Thread的子类，存放于线程池中的工作线程（Worker）；</p><p><img src="'+k+`" alt="image-20200716083953114"></p></li><li><p><strong>WorkQueue</strong>：任务队列，用于保存任务；</p></li></ul><h4 id="_1-2-3-基本使用" tabindex="-1"><a class="header-anchor" href="#_1-2-3-基本使用"><span>1.2.3 基本使用</span></a></h4><p>一个典型的例子：计算1-1000的和</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>package com.itheima.thread;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.concurrent.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class SumTask {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private static final Integer MAX = 100;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    static class SubTask extends RecursiveTask&lt;Integer&gt; {</span></span>
<span class="line"><span>        // 子任务开始计算的值</span></span>
<span class="line"><span>        private Integer start;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 子任务结束计算的值</span></span>
<span class="line"><span>        private Integer end;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        public SubTask(Integer start , Integer end) {</span></span>
<span class="line"><span>            this.start = start;</span></span>
<span class="line"><span>            this.end = end;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected Integer compute() {</span></span>
<span class="line"><span>            if(end - start &lt; MAX) {</span></span>
<span class="line"><span>                //小于边界，开始计算</span></span>
<span class="line"><span>                System.out.println(&quot;start = &quot; + start + &quot;;end = &quot; + end);</span></span>
<span class="line"><span>                Integer totalValue = 0;</span></span>
<span class="line"><span>                for(int index = this.start ; index &lt;= this.end  ; index++) {</span></span>
<span class="line"><span>                    totalValue += index;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                return totalValue;</span></span>
<span class="line"><span>            }else {</span></span>
<span class="line"><span>                //否则，中间劈开继续拆分</span></span>
<span class="line"><span>                SubTask subTask1 = new SubTask(start, (start + end) / 2);</span></span>
<span class="line"><span>                subTask1.fork();</span></span>
<span class="line"><span>                SubTask subTask2 = new SubTask((start + end) / 2 + 1 , end);</span></span>
<span class="line"><span>                subTask2.fork();</span></span>
<span class="line"><span>                return subTask1.join() + subTask2.join();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        ForkJoinPool pool = new ForkJoinPool();</span></span>
<span class="line"><span>        Future&lt;Integer&gt; taskFuture =  pool.submit(new SubTask(1,1000));</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Integer result = taskFuture.get();</span></span>
<span class="line"><span>            System.out.println(&quot;result = &quot; + result);</span></span>
<span class="line"><span>        } catch (InterruptedException | ExecutionException e) {</span></span>
<span class="line"><span>            e.printStackTrace(System.out);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-2-4-设计思想" tabindex="-1"><a class="header-anchor" href="#_1-2-4-设计思想"><span>1.2.4 设计思想</span></a></h4><ul><li><p>普通线程池内部有两个重要集合：工作线程集合（普通线程），和任务队列。</p></li><li><p>ForkJoinPool也类似，线程集合里放的是特殊线程ForkJoinWorkerThread，任务队列里放的是特殊任务ForkJoinTask</p></li><li><p>不同之处在于，普通线程池只有一个队列。而ForkJoinPool的工作线程ForkJoinWorkerThread每个线程内都绑定一个双端队列。</p><p><img src="`+v+'" alt="image-20200714164029991"></p></li><li><p>在fork的时候，也就是任务拆分，将拆分的task会被当前线程放到自己的队列中。</p></li><li><p>如果有任务，那么线程优先从自己的队列里取任务执行，以<code>LIFO</code>先进后出方式从队尾获取任务，</p></li><li><p>当自己队列中执行完后，工作线程会跑到其他队列以<code>work−stealing</code>窃取,窃取方式为<code>FIFO</code>先进先出，减少竞争。</p></li></ul><h4 id="_1-2-5-注意点" tabindex="-1"><a class="header-anchor" href="#_1-2-5-注意点"><span>1.2.5 注意点</span></a></h4><p>使用ForkJoin将相同的计算任务通过多线程执行。但是在使用中需要注意：</p><ul><li>注意任务切分的粒度，也就是fork的界限。并非越小越好</li><li>判断要不要使用ForkJoin。任务量不是太大的话，串行可能优于并行。因为多线程会涉及到上下文的切换</li></ul><h3 id="_1-3-原子操作" tabindex="-1"><a class="header-anchor" href="#_1-3-原子操作"><span>1.3 原子操作</span></a></h3><h4 id="_1-3-1-概念" tabindex="-1"><a class="header-anchor" href="#_1-3-1-概念"><span>1.3.1 概念</span></a></h4><p>​ 原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为&quot;不可被中断的一个或一系列操作&quot; 。</p><h4 id="_1-3-2-cas" tabindex="-1"><a class="header-anchor" href="#_1-3-2-cas"><span>1.3.2 CAS</span></a></h4><p>​ CAS（Compare-and-Swap/Exchange），即比较并替换，是一种实现并发常用到的技术。CAS的整体架构如下：</p><p><img src="'+u+`" alt="image-20231003081920956"></p><p>​ juc中提供了Atomic开头的类，基于cas实现原子性操作，最基本的应用就是计数器</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>package com.itheima;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.concurrent.atomic.AtomicInteger;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class AtomicCounter {</span></span>
<span class="line"><span>    private static AtomicInteger i = new AtomicInteger(0);</span></span>
<span class="line"><span>    public int get(){</span></span>
<span class="line"><span>        return i.get();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    public void inc(){</span></span>
<span class="line"><span>        i.incrementAndGet();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) throws InterruptedException {</span></span>
<span class="line"><span>        final AtomicCounter counter = new AtomicCounter();</span></span>
<span class="line"><span>        for (int i = 0; i &lt; 10; i++) {</span></span>
<span class="line"><span>            new Thread(new Runnable() {</span></span>
<span class="line"><span>                public void run() {</span></span>
<span class="line"><span>                    counter.inc();</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }).start();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        Thread.sleep(3000);</span></span>
<span class="line"><span>        //可以正确输出10</span></span>
<span class="line"><span>        System.out.println(counter.i.get());</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>注：AtomicInteger源码。基于unsafe类cas思想实现，性能篇会讲到</em></p><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p><ol><li>自旋(循环)时间长开销很大，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销，注意这里的自旋是在用户态/SDK 层面实现的。</li><li>只能保证一个共享变量的原子操作，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</li><li>ABA问题，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比CAS更高效。</li></ol><h4 id="_1-3-3-atomic" tabindex="-1"><a class="header-anchor" href="#_1-3-3-atomic"><span>1.3.3 atomic</span></a></h4><p>​ 上面展示了AtomicInteger，关于atomic包，还有很多其他类型：</p><ul><li>基本类型 <ul><li>AtomicBoolean：以原子更新的方式更新boolean；</li><li>AtomicInteger：以原子更新的方式更新Integer;</li><li>AtomicLong：以原子更新的方式更新Long；</li></ul></li><li>引用类型 <ul><li>AtomicReference ： 原子更新引用类型</li><li>AtomicReferenceFieldUpdater ：原子更新引用类型的字段</li><li>AtomicMarkableReference ： 原子更新带有标志位的引用类型</li></ul></li><li>数组 <ul><li>AtomicIntegerArray：原子更新整型数组里的元素。</li><li>AtomicLongArray：原子更新长整型数组里的元素。</li><li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li></ul></li><li>字段 <ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。</li></ul></li></ul><h4 id="_1-3-4-注意" tabindex="-1"><a class="header-anchor" href="#_1-3-4-注意"><span>1.3.4 注意！</span></a></h4><p>使用atomic要注意原子性的边界，把握不好会起不到应有的效果，原子性被破坏。</p><p>案例：原子性被破坏现象</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>package com.itheima;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.concurrent.atomic.AtomicInteger;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class BadAtomic {</span></span>
<span class="line"><span>    AtomicInteger i = new AtomicInteger(0);</span></span>
<span class="line"><span>    static int j=0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void badInc(){</span></span>
<span class="line"><span>        int k = i.incrementAndGet();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Thread.sleep(new Random().nextInt(100));</span></span>
<span class="line"><span>        } catch (InterruptedException e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        j=k;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) throws InterruptedException {</span></span>
<span class="line"><span>        BadAtomic atomic = new BadAtomic();</span></span>
<span class="line"><span>        for (int i = 0; i &lt; 10; i++) {</span></span>
<span class="line"><span>            new Thread(()-&gt;{</span></span>
<span class="line"><span>                atomic.badInc();</span></span>
<span class="line"><span>            }).start();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        Thread.sleep(3000);</span></span>
<span class="line"><span>        System.out.println(atomic.j);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：</p><ul><li>每次都不一样，总之不是10</li><li>i是原子性的，没问题。但是再赋值，变成了两部操作，原子性被打破</li><li>在badInc上加synchronized，问题解决</li></ul><h3 id="_1-4-aqs" tabindex="-1"><a class="header-anchor" href="#_1-4-aqs"><span>1.4 AQS</span></a></h3><h4 id="_1-4-1、前言" tabindex="-1"><a class="header-anchor" href="#_1-4-1、前言"><span>1.4.1、前言</span></a></h4><p>如果要想真正的理解<code>JUC</code>下的并发工具的实现原理，我们必须要来学习<code>AQS</code>，因为它是<code>JUC</code>下很多类的基石。</p><p>在讲解AQS之前，如果老板让你自己写一个SDK层面的锁，给其他同事去使用，你会如何写呢？</p><p>1、搞一个状态标记，用来表示持有或未持有锁，但得是<code>volatile</code>类型的保证线程可见性。</p><p>2、编写一个<code>lock</code>，<code>unlock</code>函数用于抢锁和释放锁，就是对状态标记的修改操作</p><p>3、<code>lock</code>函数要保证并发下只能有一个线程能抢到锁，其他线程要等待获取锁（阻塞式），可以采用CAS+自旋的方式实现</p><p>初步实现如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class MyLock {</span></span>
<span class="line"><span>    // 定义一个状态变量status：为1表示锁被持有，为0表示锁未被持有</span></span>
<span class="line"><span>    private volatile int status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private static final Unsafe unsafe = reflectGetUnsafe();</span></span>
<span class="line"><span>    private static final long valueOffset;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    static {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            valueOffset = unsafe.objectFieldOffset</span></span>
<span class="line"><span>                    (MyLock.class.getDeclaredField(&quot;status&quot;));</span></span>
<span class="line"><span>        } catch (Exception ex) { throw new Error(ex); }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private static Unsafe reflectGetUnsafe() {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span></span>
<span class="line"><span>            field.setAccessible(true);</span></span>
<span class="line"><span>            return (Unsafe) field.get(null);</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>            return null;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 阻塞式获取锁</span></span>
<span class="line"><span>     * @return</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public boolean lock() {</span></span>
<span class="line"><span>        while (!compareAndSet(0,1)) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // cas 设置 status</span></span>
<span class="line"><span>    public final boolean compareAndSet(int expect, int update) {</span></span>
<span class="line"><span>        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 释放锁</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public void unlock() {</span></span>
<span class="line"><span>        status = 0;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题：获取不到锁自旋时，是空转，浪费CPU</p><p>1、使用<code>yield</code>让出CPU执行权，等待调度</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public boolean lock() {</span></span>
<span class="line"><span>    while (!compareAndSet(0,1)) {</span></span>
<span class="line"><span>        Thread.yield();//yield+自旋,尽可能的防止CPU空转,让出CPU资源</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者可以采用线程休眠的方式，但是休眠时间不太好确定，太长太短都不好。</p><p>2、采用等待唤醒机制，但是这里由于没有使用<code>synchronized</code>关键字，所以也无法使用<code>wait/notify</code>，但是我们可以使用<code>park/unpark</code>，获取不到锁的线程<code>park</code>并且去队列排队，释放锁时从队列拿出一个线程<code>unpark</code></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>private static final Queue&lt;Thread&gt; QUEUE = new LinkedBlockingQueue&lt;&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean lock() {</span></span>
<span class="line"><span>    while (!compareAndSet(0,1)) {</span></span>
<span class="line"><span>        QUEUE.offer(Thread.currentThread());</span></span>
<span class="line"><span>        LockSupport.park();//线程休眠</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void unlock() {</span></span>
<span class="line"><span>    status = 0;</span></span>
<span class="line"><span>    LockSupport.unpark(QUEUE.poll());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-4-2、aqs概述" tabindex="-1"><a class="header-anchor" href="#_1-4-2、aqs概述"><span>1.4.2、AQS概述</span></a></h4><p>AQS（AbstractQueuedSynchronizer）：抽象队列同步器，定义了一套多线程访问共享资源的同步器框架，提供了SDK层面的锁机制，JUC中的很多类譬如：ReentrantLock/Semaphore/CountDownLatch......等都是基于它。</p><p>通过查阅作者的对于该类的文档注释可以得到如下核心信息：</p><p>1、AQS用一个<code>volatile int state;</code>属性表示锁状态，1表示锁被持有，0表示未被持有，具体的维护由子类去维护，但是提供了修改该属性的三个方法：<code>getState()</code>，<code>setState(int newState)</code>，<code>compareAndSetState(int expect, int update)</code>，其中CAS方法是核心。</p><p>2、框架内部维护了一个FIFO的等待队列，是用双向链表实现的，我们称之为CLH队列，</p><p>3、框架也内部也实现了条件变量<code>Condition</code>，用它来实现等待唤醒机制，并且支持多个条件变量</p><p>4、AQS支持两种资源共享的模式：独占模式（Exclusive）和共享模式（Share），所谓独占模式就是任意时刻只允许一个线程访问共享资源，譬如ReentrantLock；而共享模式指的就是允许多个线程同时访问共享资源，譬如Semaphore/CountDownLatch</p><p>5、使用者只需继承<code>AbstractQueuedSynchronizer</code>并重写指定的方法，在方法内完成对共享资源<code>state</code>的获取和释放，至于具体线程等待队列的维护，AQS已经在顶层实现好了，在那些<code>final</code>的模板方法里。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>* &lt;p&gt;To use this class as the basis of a synchronizer, redefine the</span></span>
<span class="line"><span> * following methods, as applicable, by inspecting and/or modifying</span></span>
<span class="line"><span> * the synchronization state using {@link #getState}, {@link</span></span>
<span class="line"><span> * #setState} and/or {@link #compareAndSetState}:</span></span>
<span class="line"><span> *</span></span>
<span class="line"><span> * &lt;ul&gt;</span></span>
<span class="line"><span> * &lt;li&gt; {@link #tryAcquire}</span></span>
<span class="line"><span> * &lt;li&gt; {@link #tryRelease}</span></span>
<span class="line"><span> * &lt;li&gt; {@link #tryAcquireShared}</span></span>
<span class="line"><span> * &lt;li&gt; {@link #tryReleaseShared}</span></span>
<span class="line"><span> * &lt;li&gt; {@link #isHeldExclusively}</span></span>
<span class="line"><span> * &lt;/ul&gt;</span></span>
<span class="line"><span> *</span></span>
<span class="line"><span> * Each of these methods by default throws {@link</span></span>
<span class="line"><span> * UnsupportedOperationException}.  Implementations of these methods</span></span>
<span class="line"><span> * must be internally thread-safe, and should in general be short and</span></span>
<span class="line"><span> * not block. Defining these methods is the &lt;em&gt;only&lt;/em&gt; supported</span></span>
<span class="line"><span> * means of using this class. All other methods are declared</span></span>
<span class="line"><span> * {@code final} because they cannot be independently varied.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6、AQS底层使用了模板方法模式，给我们提供了许多模板方法，我们直接使用即可。</p><table><thead><tr><th>API</th><th>说明</th><th></th></tr></thead><tbody><tr><td>final void acquire(int arg)</td><td>独占模式获取锁，AQS顶层已实现，内部调用了tryAcquire</td><td>模板方法</td></tr><tr><td>boolean tryAcquire(int arg)</td><td>独占模式尝试获取锁，AQS中未实现，由子类去实现，获取到锁返回true</td><td></td></tr><tr><td>final boolean release(int arg)</td><td>释放独占锁，AQS顶层已实现，内部调用了tryRelease</td><td>模板方法</td></tr><tr><td>boolean tryRelease(int arg)</td><td>尝试释放独占锁，AQS中未实现，由子类去实现，成功释放返回true</td><td></td></tr><tr><td>final void acquireShared(int arg)</td><td>共享模式获取锁，AQS顶层已实现，内部调用了tryAcquireShared</td><td>模板方法</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>尝试获取共享锁，返回负数表示失败，0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源，AQS中未实现，由子类实现</td><td></td></tr><tr><td>final boolean releaseShared(int arg)</td><td>释放共享锁，返回true代表释放成功，AQS中已实现，内部调用了tryReleaseShared</td><td>模板方法</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>尝试释放锁，释放后允许唤醒后续等待结点返回true，否则返回false，AQS中未实现，需要由子类实现</td><td></td></tr><tr><td>boolean isHeldExclusively()</td><td>共享资源是否被独占</td><td></td></tr></tbody></table><h4 id="_1-4-3、基本使用" tabindex="-1"><a class="header-anchor" href="#_1-4-3、基本使用"><span>1.4.3、基本使用</span></a></h4><p>此时老板给你加了需求，要求你实现一个基于AQS的锁，那该怎么办呢？</p><p>在<code>AbstractQueuedSynchronizer</code>的类注释中给出了使用它的基本方法，我们按照它的写法尝试即可</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>/**</span></span>
<span class="line"><span> * 基于 aqs实现锁</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>public class MyLock implements Lock {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //同步器</span></span>
<span class="line"><span>    private Syn syn = new Syn();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void lock() {</span></span>
<span class="line"><span>        //调用模板方法</span></span>
<span class="line"><span>        syn.acquire(1);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void unlock() {</span></span>
<span class="line"><span>        //调用模板方法</span></span>
<span class="line"><span>        syn.release(0);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 其他接口方法暂时先不实现 省略</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 实现一个独占同步器</span></span>
<span class="line"><span>    class Syn extends AbstractQueuedSynchronizer{</span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryAcquire(int arg) {</span></span>
<span class="line"><span>            if (compareAndSetState(0,arg)) {</span></span>
<span class="line"><span>                return true;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryRelease(int arg) {</span></span>
<span class="line"><span>            setState(arg);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-4-4、原理解析" tabindex="-1"><a class="header-anchor" href="#_1-4-4、原理解析"><span>1.4.4、原理解析</span></a></h4><p>自己实现的锁在使用过程中发现一个问题，就是有时候有的线程特别容易抢到锁，而有的线程老是抢不到锁，虽说线程们抢锁确实看命，但能不能加入一种设计，让各个线程机会均等些，起码不要出现某几个线程总是特倒霉抢不到锁的情况吧！</p><p>这其实就是涉及到锁是否是公平的，那么什么是公平锁什么是非公平锁呢？</p><p>这我们就不得不深入我们使用的模板方法中看一眼了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>/**</span></span>
<span class="line"><span>     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span>
<span class="line"><span>     * by invoking at least once {@link #tryAcquire},</span></span>
<span class="line"><span>     * returning on success.  Otherwise the thread is queued, possibly</span></span>
<span class="line"><span>     * repeatedly blocking and unblocking, invoking {@link</span></span>
<span class="line"><span>     * #tryAcquire} until success.  This method can be used</span></span>
<span class="line"><span>     * to implement method {@link Lock#lock}.</span></span>
<span class="line"><span>     *</span></span>
<span class="line"><span>     * @param arg the acquire argument.  This value is conveyed to</span></span>
<span class="line"><span>     *        {@link #tryAcquire} but is otherwise uninterpreted and</span></span>
<span class="line"><span>     *        can represent anything you like.</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>public final void acquire(int arg) {</span></span>
<span class="line"><span>    if (!tryAcquire(arg) &amp;&amp;</span></span>
<span class="line"><span>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></span>
<span class="line"><span>        selfInterrupt();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//结合我自己写的尝试获取锁的方法</span></span>
<span class="line"><span>protected boolean tryAcquire(int arg) {</span></span>
<span class="line"><span>    if (compareAndSetState(0,arg)) {</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里大概描述如下：</p><p>1、线程一来首先调用<code>tryAcquire</code>，在<code>tryAcquire</code>中直接CAS获取锁，如果获取不成功通过<code>addWaiter</code>加入等待队列，然后走<code>acquireQueued</code>让队列中的某个等待线程去获取锁。</p><p>2、不公平就体现在这里，线程来了也不先看一下等待队列中是否有线程在等待，如果没有线程等待，那直接获取锁没什么 问题，如果有线程等待就直接去获取锁不就相当于插队么？</p><p>那如何实现这种公平性呢？这就不得不探究一下AQS的内部的实现原理了，下面我们依次来看：</p><p>1、查看<code>AbstractQueuedSynchronizer</code>的类定义，虽然它里面代码很多，但重要的属性就那么几个，</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer</span></span>
<span class="line"><span>    implements java.io.Serializable {</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    private volatile int state;</span></span>
<span class="line"><span>    private transient volatile Node head;</span></span>
<span class="line"><span>    private transient volatile Node tail;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    static final class Node {</span></span>
<span class="line"><span>        //其他不重要的略</span></span>
<span class="line"><span>        volatile int waitStatus;</span></span>
<span class="line"><span>        volatile Node prev;</span></span>
<span class="line"><span>        volatile Node next;</span></span>
<span class="line"><span>        volatile Thread thread;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    public class ConditionObject implements Condition, java.io.Serializable {...}</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合前面讲的AQS的类文档注释不难猜到，内部类 <code>Node</code>以及其类型的变量 <code>head</code> 和 <code>tail</code> 就表示 AQS 内部的一个等待队列，而剩下的 <code>state</code> 变量就用来表示锁的状态。</p><p>等待队列应该就是线程获取锁失败时，需要临时存放的一个地方，用来等待被唤醒并尝试获取锁。再看 <code>Node</code> 的属性我们知道，<code>Node</code> 存放了当前线程的指针 <code>thread</code>，也即可以表示当前线程并对其进行某些操作，<code>prev</code> 和 <code>next</code> 说明它构成了一个双向链表，也就是为某些需要得到前驱或后继节点的算法提供便利。</p><p>2、AQS加锁最核心的代码就是如下，我们要来探究它的实现原理</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public final void acquire(int arg) {</span></span>
<span class="line"><span>    if (!tryAcquire(arg) &amp;&amp;</span></span>
<span class="line"><span>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></span>
<span class="line"><span>        selfInterrupt();</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的原理及整个过程我们以图的形式说明如下：</p><p><img src="`+o+`" alt="image-20231003081934377"></p><p>3、原理搞懂了，那如何让自定义的锁是公平的呢？</p><p>其实导致不公平的原因就是线程每次调用<code>acquire</code>时，都会先去<code>tryAcquire</code>，而该方法目前的实现时直接去抢锁，也不看现在等待队列中有没有线程在排队，如果有线程在排队，那岂不是变成了插队，导致不公平。</p><p>所以现在的解决办法就是，在<code>tryAcquire</code>时先看一下等待队列中是否有在排队的，如果有那就乖乖去排队，不插队，如果没有则可以直接去获取锁。</p><p>那如何知道线程AQS等待队列中是否有线程排队呢？其实AQS顶层已经实现好了，它提供了一个<code>hasQueuedPredecessors</code>函数：如果在当前线程之前有一个排队的线程，则为True; 如果当前线程位于队列的头部(<code>head.next</code>)或队列为空，则为false。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>protected boolean tryAcquire(int arg) {</span></span>
<span class="line"><span>    //先判断等待队列中是否有线程在排队 没有线程排队则直接去获取锁</span></span>
<span class="line"><span>    if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0,arg)) {</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、现在已经有公平锁了，但是成年人的世界不是做选择题，而是都想要，自己编写的锁既能支持公平锁，也支持非公平锁，让使用者可以自由选择，怎么办？</p><p>其实只要稍微改造一下即可，</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class MyLock implements Lock {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //同步器</span></span>
<span class="line"><span>    private Sync syn ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    MyLock () {</span></span>
<span class="line"><span>        syn = new NoFairSync();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    MyLock (boolean fair) {</span></span>
<span class="line"><span>        syn = fair ? new FairSync():new NoFairSync();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void lock() {</span></span>
<span class="line"><span>        //调用模板方法</span></span>
<span class="line"><span>        syn.acquire(1);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void unlock() {</span></span>
<span class="line"><span>        //调用模板方法</span></span>
<span class="line"><span>        syn.release(0);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Lock接口其他方法暂时先不实现 略</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 实现一个独占同步器</span></span>
<span class="line"><span>    class Sync extends AbstractQueuedSynchronizer{</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryRelease(int arg) {</span></span>
<span class="line"><span>            setState(arg);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class FairSync extends Sync {</span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryAcquire(int arg) {</span></span>
<span class="line"><span>            //先判断等待队列中是否有线程在排队 没有线程排队则直接去获取锁</span></span>
<span class="line"><span>            if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0,arg)) {</span></span>
<span class="line"><span>                return true;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class NoFairSync extends Sync {</span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryAcquire(int arg) {</span></span>
<span class="line"><span>            //直接去获取锁</span></span>
<span class="line"><span>            if (compareAndSetState(0,arg)) {</span></span>
<span class="line"><span>                return true;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5、现在锁的公平性问题解决了，但是老板又出了新的需求，要求我们的锁支持可重入，因为它写了如下一段代码，发现一直获取不到锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static Lock lock = new MyLock();</span></span>
<span class="line"><span>static void test3() {</span></span>
<span class="line"><span>    lock.lock();</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        System.out.println(&quot;test3 get lock,then do something &quot;);</span></span>
<span class="line"><span>        test4();</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        lock.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>static void test4() {</span></span>
<span class="line"><span>    lock.lock();</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        System.out.println(&quot;test4 get lock,then do something &quot;);</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        lock.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那如何让锁支持可重入呢？也就是说如果一个线程持有锁之后，还能继续获取锁，也就是说让锁只对不同线程互斥。</p><p>查看<code>AbstractQueuedSynchronizer</code>的定义我们发现，它还继承自另一个类：<code>AbstractOwnableSynchronizer</code></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer</span></span>
<span class="line"><span>    implements java.io.Serializable {...}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public abstract class AbstractOwnableSynchronizer</span></span>
<span class="line"><span>    implements java.io.Serializable {</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    private transient Thread exclusiveOwnerThread;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    protected final void setExclusiveOwnerThread(Thread thread) {...}</span></span>
<span class="line"><span>    protected final Thread getExclusiveOwnerThread(){...}</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这我们明白了，原来<code>AQS</code>中有个变量是可以保存当前持有独占锁的线程的。那好办了，当我们获取锁时，如果发现锁被持有不要着急放弃，先看看持有锁的线程是否时当前线程，如果是还能继续获取锁。</p><p>另外关于可重入锁，还要注意一点，锁的获取和释放操作是成对出现的，就像下面这样</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>lock</span></span>
<span class="line"><span>    lock</span></span>
<span class="line"><span>        lock</span></span>
<span class="line"><span>            lock</span></span>
<span class="line"><span>                ....</span></span>
<span class="line"><span>            unlock</span></span>
<span class="line"><span>        unlock</span></span>
<span class="line"><span>    unlock</span></span>
<span class="line"><span>unlock</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以对于重入锁不仅要能记录锁被持有，还要记录重入的次数，释放的时候也不是直接将锁真实的释放，而是先减少重入次数，能释放的时候在释放。</p><p>故此时状态变量<code>state</code>不在只有两个取值<code>0,1</code>，某线程获取到锁<code>state=1</code>，如果当前线程重入获取只需增加状态值<code>state=2</code>，依次同理，锁释放时释放一次状态值<code>-1</code>，当<code>state=0</code>时才真正释放，其他线程才能继续获取锁。</p><p>修改我们锁的代码如下：公平非公平在可重入上的逻辑是一样的</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class MyLock implements Lock {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //同步器</span></span>
<span class="line"><span>    private Sync syn ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    MyLock () {</span></span>
<span class="line"><span>        syn = new NoFairSync();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    MyLock (boolean fair) {</span></span>
<span class="line"><span>        syn = fair ? new FairSync():new NoFairSync();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void lock() {</span></span>
<span class="line"><span>        //调用模板方法</span></span>
<span class="line"><span>        syn.acquire(1);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void unlock() {</span></span>
<span class="line"><span>        //调用模板方法</span></span>
<span class="line"><span>        syn.release(1);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Lock接口其他方法暂时先不实现 略</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 实现一个独占同步器</span></span>
<span class="line"><span>    class Sync extends AbstractQueuedSynchronizer{</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryRelease(int arg) {</span></span>
<span class="line"><span>            if (Thread.currentThread() != getExclusiveOwnerThread()) {</span></span>
<span class="line"><span>                throw new IllegalMonitorStateException();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            boolean realRelease = false;</span></span>
<span class="line"><span>            int nextState = getState() - arg;</span></span>
<span class="line"><span>            if (nextState == 0) {</span></span>
<span class="line"><span>                realRelease = true;</span></span>
<span class="line"><span>                setExclusiveOwnerThread(null);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            setState(nextState);</span></span>
<span class="line"><span>            return realRelease;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class FairSync extends Sync {</span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryAcquire(int arg) {</span></span>
<span class="line"><span>            final Thread currentThread = Thread.currentThread();</span></span>
<span class="line"><span>            int currentState = getState();</span></span>
<span class="line"><span>            if (currentState == 0 ) { // 可以获取锁</span></span>
<span class="line"><span>                //先判断等待队列中是否有线程在排队 没有线程排队则直接去获取锁</span></span>
<span class="line"><span>                if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0,arg)) {</span></span>
<span class="line"><span>                    setExclusiveOwnerThread(currentThread);</span></span>
<span class="line"><span>                    return true;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }else if (currentThread == getExclusiveOwnerThread()) {</span></span>
<span class="line"><span>                //重入逻辑 增加 state值</span></span>
<span class="line"><span>                int nextState = currentState + arg;</span></span>
<span class="line"><span>                if (nextState &lt; 0) {</span></span>
<span class="line"><span>                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                setState(nextState);</span></span>
<span class="line"><span>                return true;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class NoFairSync extends Sync {</span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        protected boolean tryAcquire(int arg) {</span></span>
<span class="line"><span>            final Thread currentThread = Thread.currentThread();</span></span>
<span class="line"><span>            int currentState = getState();</span></span>
<span class="line"><span>            if (currentState ==0 ) { // 可以获取锁</span></span>
<span class="line"><span>                //直接去获取锁</span></span>
<span class="line"><span>                if (compareAndSetState(0,arg)) {</span></span>
<span class="line"><span>                    setExclusiveOwnerThread(currentThread);</span></span>
<span class="line"><span>                    return true;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }else if (currentThread == getExclusiveOwnerThread()) {</span></span>
<span class="line"><span>                //重入逻辑 增加 state值</span></span>
<span class="line"><span>                int nextState = currentState + arg;</span></span>
<span class="line"><span>                if (nextState &lt; 0) {</span></span>
<span class="line"><span>                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                setState(nextState);</span></span>
<span class="line"><span>                return true;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好了至此我们已经掌握了<code>AQS</code>的核心原理以及它的一个经典实现<code>ReentrantLock</code>几乎全部的知识点，此时打开<code>ReentrantLock</code>的源码你会发现一切都很清爽！！！</p><h3 id="_1-5-并发容器" tabindex="-1"><a class="header-anchor" href="#_1-5-并发容器"><span>1.5 并发容器</span></a></h3><p>juc中还包含很多其他的并发容器（了解）</p><p><strong>1.ConcurrentHashMap</strong></p><p>对应：HashMap</p><p>目标：代替Hashtable、synchronizedMap，使用最多，源码篇会详细讲解</p><p>原理：JDK7中采用Segment分段锁，JDK8中采用CAS+synchronized</p><p><strong>2.CopyOnWriteArrayList</strong></p><p>对应：ArrayList</p><p>目标：代替Vector、synchronizedList</p><p>原理：高并发往往是读多写少的特性，读操作不加锁，而对写操作加Lock独享锁，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过volatile 保证其可见性。</p><p><em>查看源码：volatile array，lock加锁，数组复制</em></p><p><strong>3.CopyOnWriteArraySet</strong></p><p>对应：HashSet</p><p>目标：代替synchronizedSet</p><p>原理：与CopyOnWriteArrayList实现原理类似。</p><p><strong>4.ConcurrentSkipListMap</strong></p><p>对应：TreeMap</p><p>目标：代替synchronizedSortedMap(TreeMap)</p><p>原理：基于Skip list（跳表）来代替平衡树，按照分层key上下链接指针来实现。</p><p><em>附加：跳表</em></p><p><strong>5.ConcurrentSkipListSet</strong></p><p>对应：TreeSet</p><p>目标：代替synchronizedSortedSet(TreeSet)</p><p>原理：内部基于ConcurrentSkipListMap实现，原理一致</p><p><strong>6.ConcurrentLinkedQueue</strong></p><p>对应：LinkedList</p><p>对应：无界线程安全队列</p><p>原理：通过队首队尾指针，以及Node类元素的next实现FIFO队列</p><p><strong>7.BlockingQueue</strong></p><p>对应：Queue</p><p>特点：拓展了Queue，增加了可阻塞的插入和获取等操作</p><p>原理：通过ReentrantLock实现线程安全，通过Condition实现阻塞和唤醒</p><p>实现类：</p><ul><li>LinkedBlockingQueue：基于链表实现的可阻塞的FIFO队列</li><li>ArrayBlockingQueue：基于数组实现的可阻塞的FIFO队列</li><li>PriorityBlockingQueue：按优先级排序的队列</li></ul><h2 id="_2、并发深入" tabindex="-1"><a class="header-anchor" href="#_2、并发深入"><span>2、并发深入</span></a></h2><h3 id="_2-1-基本协同" tabindex="-1"><a class="header-anchor" href="#_2-1-基本协同"><span>2.1 基本协同</span></a></h3><p>先搞懂线程协作的一些基本操作，面试经常要用到！</p><h4 id="_2-1-1-object" tabindex="-1"><a class="header-anchor" href="#_2-1-1-object"><span>2.1.1 Object</span></a></h4><p>1）wait：让出锁，阻塞等待</p><p>2）notify/notifyAll：唤醒wait的进程。</p><p><em>notifyAll测试，猜一下输出？</em></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>package com.itheima.busi;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class NotifyTest {</span></span>
<span class="line"><span>    public static void main(String[] args) throws Exception{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        byte[] lock = new byte[0];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Thread t1 = new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                try {</span></span>
<span class="line"><span>                    lock.wait();</span></span>
<span class="line"><span>                    System.out.println(&quot;t1 started&quot;);</span></span>
<span class="line"><span>                } catch (InterruptedException e) {</span></span>
<span class="line"><span>                    e.printStackTrace();</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Thread t2 = new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                try {</span></span>
<span class="line"><span>                    lock.wait();</span></span>
<span class="line"><span>                    System.out.println(&quot;t2 started&quot;);</span></span>
<span class="line"><span>                } catch (InterruptedException e) {</span></span>
<span class="line"><span>                    e.printStackTrace();</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Thread t3 = new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                try {</span></span>
<span class="line"><span>                    Thread.sleep(1000);</span></span>
<span class="line"><span>                    System.out.println(&quot;t3 notify&quot;);</span></span>
<span class="line"><span>                    lock.notifyAll();</span></span>
<span class="line"><span>                } catch (InterruptedException e) {</span></span>
<span class="line"><span>                    e.printStackTrace();</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        t1.setPriority(1);</span></span>
<span class="line"><span>        t2.setPriority(3);</span></span>
<span class="line"><span>        t3.setPriority(2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        t1.start();</span></span>
<span class="line"><span>        TimeUnit.MILLISECONDS.sleep(10);</span></span>
<span class="line"><span>        t2.start();</span></span>
<span class="line"><span>        TimeUnit.MILLISECONDS.sleep(10);</span></span>
<span class="line"><span>        t3.start();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果分析：wait让出锁，t3得到执行，t3唤醒后，虽然t1先start，但是优先级低，所以t2优先执行（注意是概率，不是绝对的！）</p><p><em>扩展：jdk1.5+的lock中支持条件变量， Condition.await()，signal/signalAll</em> 与 wait/notify效果一样，可以做到更精细化控制</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ReentrantLock lock = new ReentrantLock();</span></span>
<span class="line"><span>Condition c1 = lock.newCondition();</span></span>
<span class="line"><span>Condition c2 = lock.newCondition();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>c1.await();</span></span>
<span class="line"><span>//do something...</span></span>
<span class="line"><span>c1.signal();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>c2.await();</span></span>
<span class="line"><span>//do other things...</span></span>
<span class="line"><span>c2.signalAll();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>lock.unlock();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-1-2-thread" tabindex="-1"><a class="header-anchor" href="#_2-1-2-thread"><span>2.1.2 Thread</span></a></h4><p>1）sleep：暂停一下，只是让出CPU的执行权，并不释放锁。</p><p>猜一下结果……</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>package com.itheima;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class SleepTest{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        final byte[] lock = new byte[0];</span></span>
<span class="line"><span>        new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                System.out.println(&quot;start&quot;);</span></span>
<span class="line"><span>                try {</span></span>
<span class="line"><span>                    Thread.sleep(3000);</span></span>
<span class="line"><span>                } catch (InterruptedException e) {</span></span>
<span class="line"><span>                    e.printStackTrace();</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                System.out.println(&quot;end&quot;);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }).start();</span></span>
<span class="line"><span>                //Thread.sleep(100);</span></span>
<span class="line"><span>        new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                System.out.println(&quot;need lock&quot;);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }).start();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析：</p><p>新的thread无法异步执行，被迫等待锁，跟着sleep</p><p>2）yield：不释放锁，运行中转为就绪，让出cpu给大家去竞争。当然有可能自己又抢了回来</p><p>想一下，以下代码有可能是什么结果……</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>package com.itheima;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class YieldTest{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) throws InterruptedException {</span></span>
<span class="line"><span>        final byte[] lock = new byte[0];</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>        //让出执行权，但是锁不释放</span></span>
<span class="line"><span>        Thread t1 = new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                System.out.println(&quot;t1 : before yield&quot;);</span></span>
<span class="line"><span>                Thread.yield();</span></span>
<span class="line"><span>                System.out.println(&quot;t1 : after yield&quot;);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        //可以抢t1，但是拿不到锁，白费</span></span>
<span class="line"><span>        Thread t2 = new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                System.out.println(&quot;t2 : need lock&quot;);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        //不需要锁，可以抢t1的执行权，但是能不能抢得到，不一定</span></span>
<span class="line"><span>        //所以多执行几次，会看到不同的结果……</span></span>
<span class="line"><span>        Thread t3 = new Thread(()-&gt;{</span></span>
<span class="line"><span>            System.out.println(&quot;t3 : no lock&quot;);</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>        t1.start();</span></span>
<span class="line"><span>        t2.start();</span></span>
<span class="line"><span>        t3.start();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析：</p><p>t3会插队抢到执行权，但是t2不会，因为t2和t1共用一把锁而yield不会释放</p><p>t3不见得每次都能抢到。可能t1让出又抢了回去</p><p>3）join：父线程等待子线程执行完成后再执行，将异步转为同步。</p><p>注意调起的是子线程，阻断的是父线程。</p><p>一个典型的join案例，打开和关闭join看下结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public static void main(String[] args) throws Exception{</span></span>
<span class="line"><span>    Thread sub = new Thread(new JoinTest());</span></span>
<span class="line"><span>    sub.start();</span></span>
<span class="line"><span>    //        sub.join();</span></span>
<span class="line"><span>    System.out.println(&quot;I am main 1 &quot;);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>static class JoinTest implements Runnable{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void run() {</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            Thread.sleep(1000);</span></span>
<span class="line"><span>        } catch (InterruptedException e) {</span></span>
<span class="line"><span>            e.printStackTrace();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        System.out.println(&quot;I am sub 2&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析：</p><p>如果不join，main先跑完</p><p>如果join，main必须等待sub之后才输出</p><p>调用join会不会释放锁呢？用事实来说明，运行以下案例……</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public static void main(String[] args) throws Exception{</span></span>
<span class="line"><span>        System.out.println(&quot;main.start&quot;);</span></span>
<span class="line"><span>        JoinTest test = new JoinTest();</span></span>
<span class="line"><span>        Thread sub = new Thread(test);</span></span>
<span class="line"><span>        synchronized (test.lock){</span></span>
<span class="line"><span>            System.out.println(&quot;main:before sub&quot;);</span></span>
<span class="line"><span>            //1.为什么不会死锁？</span></span>
<span class="line"><span>            sub.start();</span></span>
<span class="line"><span>            System.out.println(&quot;main:after sub&quot;);</span></span>
<span class="line"><span>            //2.打开join试试：如果线程卡死，说明main不释放锁，如果可以顺利执行，说明sub拿到了锁！</span></span>
<span class="line"><span>            //sub.join();</span></span>
<span class="line"><span>            System.out.println(&quot;main after join&quot;);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        System.out.println(&quot;main.end&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    static class JoinTest implements Runnable{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        byte[] lock = new byte[0];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        public void run() {</span></span>
<span class="line"><span>            synchronized (lock){</span></span>
<span class="line"><span>                System.out.println(&quot;I am sub&quot;);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-线程的三大特性" tabindex="-1"><a class="header-anchor" href="#_2-2-线程的三大特性"><span>2.2 线程的三大特性</span></a></h3><p>线程的三大特性：</p><ul><li>可见性：Visibility</li><li>有序性：Ordering</li><li>原子性：Atomicity</li></ul><p>而这三个特性往往是并发编程bug的源头，而并发编程的bug往往也都是疑难杂症，如果想要快速定位这些问题的根源，我们就得理解这些问题的本质，而这些又跟我们底层操作系统和硬件设备有关系。</p><p><strong>三大特性的根源</strong></p><p>我们知道CPU，内存，IO设备是一台计算机的核心组成部分，三者虽然都在不断的迭代，不断的变快，但在这个大家都在发展的历史长河中一直都存在一个主要矛盾：三者之间的速度存在着量级上的差异，我们都知道CPU远快于内存，内存远远快于IO设备。</p><p>为了合理利用 CPU ，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ul><li>CPU 添加高速缓存，来平衡与内存的速度差异；</li><li>操作系统支持多进程、多线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li></ul><p>而并发编程很多bug的根源也都在这里。</p><h4 id="_2-2-1、cpu缓存导致可见性问题" tabindex="-1"><a class="header-anchor" href="#_2-2-1、cpu缓存导致可见性问题"><span>2.2.1、CPU缓存导致可见性问题</span></a></h4><p>如下图所示：</p><p><img src="`+g+'" alt="image-20231003081853814"></p><p>对于共享变量<code>i</code>，首先要将其从内存中读到CPU中，然后对其进行相关操作，如果线程A对其进行了修改操作，线程B能够立马看到线程A操作的结果，我们将其称之为线程之间的<strong>可见性</strong>。</p><p>在单核CPU架构下， 所有的线程都是在一颗 CPU 上执行，因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。</p><p>但是在多核CPU时代，每颗 CPU 都有自己的缓存，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，如下图：</p><p><img src="'+m+`" alt="image-20231003081858204"></p><p>线程A对CPU1缓存中的数据进行了修改，线程B不能立马可见，因为线程B操作的是CPU2的缓存，这就带来了多个线程操作共享变量时的数据不一致问题，具体场景见如下代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 多线程共享变量</span></span>
<span class="line"><span>private static  boolean running =  true;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private static void t1() throws InterruptedException {</span></span>
<span class="line"><span>    new Thread(()-&gt;{</span></span>
<span class="line"><span>        while (running) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        System.out.println(&quot;thread exit&quot;);</span></span>
<span class="line"><span>    }).start();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    TimeUnit.SECONDS.sleep(5);</span></span>
<span class="line"><span>    running = false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-2、线程切换导致原子性问题" tabindex="-1"><a class="header-anchor" href="#_2-2-2、线程切换导致原子性问题"><span>2.2.2、线程切换导致原子性问题</span></a></h4><p>早期计算机是单进程的，后来引入了多进程，这样即便是在单核CPU上，从宏观上我们依然可以并发执行多个程序，当然在微观上是操作系统给每个进程分配一个时间片，多个进程分时复用CPU，好处就是不会因为某个进程等待IO而浪费CPU资源，当然带来的问题是要进行CPU的调度，早期操作系统确实是以进程为单位来调度CPU的，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，如下：</p><p><img src="`+b+'" alt="image-20231003081733471"></p><p>这种切换属于一种重量级的切换，现代的操作系统都基于更轻量的线程来调度，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程切换的成本相对就很低了，并且线程切换的时机大都是在时间片结束的时候。如下：</p><p><img src="'+y+`" alt="image-20231003081737647"></p><p>这里需要注意的是我们现在一般都使用的是高级编程语言，而高级编程语言中的一句代码可能在底层对应着多条CPU的指令，拿java中如下代码来说：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 假设i的初始化值为0 </span></span>
<span class="line"><span>i+=1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在底层至少需要三条CPU指令：</p><p>1：把变量<code>i</code>的值从内存<code>load</code>到CPU寄存器</p><p>2：在CPU中执行+1的操作</p><p>3：将结果<code>store</code>到内存（当然也可能只存到CPU缓存而没刷新到内存）</p><p>虽然操作系统能保证每条指令执行的时候是具备原子性的，但是操作系统进行线程切换，可以发生在任意一条CPU指令执行完成之后（注意是CPU指令级别）。那这对高级编程语言来说多线程并发时就会造成原子性问题，如下图所示：</p><p><img src="`+A+`" alt="image-20231003081741216"></p><p>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，因此，很多时候我们需要在高级语言层面保证操作的原子性。具体场景见如下代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static class AtomicRunnable implements Runnable {</span></span>
<span class="line"><span>    int i = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public void run() {</span></span>
<span class="line"><span>        i+=1;</span></span>
<span class="line"><span>        System.out.println(&quot;---&quot;+i);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public static void main(String[] args) {</span></span>
<span class="line"><span>    AtomicRunnable runnable = new AtomicRunnable();</span></span>
<span class="line"><span>    for (int i=0;i&lt;100000;i++) {</span></span>
<span class="line"><span>        new Thread(runnable).start();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-3、性能优化导致有序性问题" tabindex="-1"><a class="header-anchor" href="#_2-2-3、性能优化导致有序性问题"><span>2.2.3、性能优化导致有序性问题</span></a></h4><p>所谓有序性，很容易想到就是程序按照代码的先后顺序来执行。但是有时候为了提高性能，在不影响最终结果的前提下会优化代码/指令的执行顺序，这里会有这两种情况的出现：</p><p><strong>编译优化</strong>：</p><p>编译器能够自由的以优化的名义去改变指令顺序，如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>x=5;</span></span>
<span class="line"><span>y=6;</span></span>
<span class="line"><span>z=x+y;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优化后可能变为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>y=6;</span></span>
<span class="line"><span>x=5;</span></span>
<span class="line"><span>z=x+y;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所谓顺序，指的是你可以用顺序的方式推演程序的执行，但是程序指令的执行不一定是完全顺序的。编译器保证结果一定 等于 顺序方式推演的结果</p><p><strong>处理器乱序执行</strong>：</p><p>为了使得处理器内部的运算单元尽量被充分利用，处理器可能会对输入指令进行乱序执行（Out-Of-Order Execution）优化，也就是说处理器可能会次序颠倒的执行指令。数据可能在寄存器，处理器缓冲区和主内存中以不同的次序移动，而不是按照程序指定的顺序，而这个是我们看不到也感知不到的，并且出现了问题也很难重现。</p><p>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。</p><ul><li><strong>单核</strong>环境下，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</li><li><strong>多核</strong>环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证。</li></ul><p>现举几个例子验证程序会出现编译优化/乱序执行的现象：</p><p>1、对象的创建有一个中间状态</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class C01_NewObject {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int m = 8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        C01_NewObject c = new C01_NewObject();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的字节码如下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>0 new #3 &lt;com/learning/ts_03_ordering/C01_NewObject&gt;</span></span>
<span class="line"><span>3 dup</span></span>
<span class="line"><span>4 invokespecial #4 &lt;com/learning/ts_03_ordering/C01_NewObject.&lt;init&gt; : ()V&gt;</span></span>
<span class="line"><span>7 astore_1</span></span>
<span class="line"><span>8 return</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们能看到在代码中一句简单的<code>new</code>对象，其实对应着多条字节码。</p><p><img src="`+f+`" alt="image-20231003081747028"></p><p>整个过程大致可分为这么几步：</p><ul><li>分配一块内存</li><li>在内存空间上初始化对象</li><li>将内存空间的地址赋值给引用变量</li></ul><p>要注意的是，在分配完内存还未初始化时，对象的实例变量是有一个初始默认值的，比如<code>int</code>就是0。初始化完成之后实例变量才会赋真正的值。</p><p>有了这些知识铺垫之后，我们可以来看在java中一个经典的案例就是利用双重锁校验创建单例对象，比如如下代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class Singleton {</span></span>
<span class="line"><span>  private Singleton(){}</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>  static Singleton instance;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>  static Singleton getInstance(){</span></span>
<span class="line"><span>    if (instance == null) {</span></span>
<span class="line"><span>      synchronized(Singleton.class) {</span></span>
<span class="line"><span>        if (instance == null)</span></span>
<span class="line"><span>          instance = new Singleton();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return instance;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码看似完美，其实有着很大的问题，这个问题就出现在<code>new</code>关键字上。这个<code>new</code>编译之后大致对应以下几个指令操作：</p><p>1：分配一块内存M</p><p>2：在内存M上初始化Singleton对象</p><p>3：将M的地址赋值给instance变量</p><p>但是实际经过指令优化之后可能变成这样：</p><p>1：分配一块内存M</p><p>2：将M的地址赋值给instance变量</p><p>3：在内存M上初始化Singleton对象</p><p>优化后会导致如下这个问题：线程A执行正在<code>new</code>创建对象，已经到第二个指令处了，此时线程B来到了第一个判断所在的指令处，发现<code>instance</code>已经不为null，然后将其返回，这也就导致了线程B使用了一个未初始化完成的对象，如果在访问该对象的成员变量可能就会造成空指针异常，如下图：</p><p><img src="`+D+'" alt="image-20231003081751201"></p><blockquote><p>补充知识点：线程切换是不会释放锁的。</p></blockquote><h4 id="_2-2-4、jmm-java-memory-model" tabindex="-1"><a class="header-anchor" href="#_2-2-4、jmm-java-memory-model"><span>2.2.4、JMM(Java Memory Model)</span></a></h4><p>通过上一节我们可大概总结如下：导致可见性是因为CPU缓存，导致顺序性是因为编译优化，那也意味着解决可见性和顺序性的办法就是：<strong>禁用CPU缓存和编译优化</strong>，但是这样会导致程序性能下降严重。为此我们不得不做出一个合理的取舍，相对合理的办法就是：<strong>按需禁用CPU缓存和按需优化</strong>，也就是按照程序员的意愿来做。</p><p>这里就涉及到对于java程序员不得不知的JMM，Java 内存模型是个很复杂的规范，我们需要从多个维度来看待：</p><p>1、<strong><code>内存模型</code></strong> 这个概念。我们可以理解为：<strong>在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。不同架构的物理计算机可以有不一样的内存模型，JVM 也有自己的内存模型。</p><p>2、JVM 中试图定义一种 Java 内存模型（Java Memory Model, JMM）来<strong>屏蔽各种硬件和操作系统的内存访问差异</strong>，以实现让 Java 程序 <strong>在各种平台下都能达到一致的内存访问效果</strong></p><p>3、从开发者角度而言，Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。</p><p>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及 <strong>Happens-Before 规则</strong></p><h5 id="主内存与工作内存" tabindex="-1"><a class="header-anchor" href="#主内存与工作内存"><span>主内存与工作内存</span></a></h5><p>JMM 的主要目标是 <strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</strong>。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p><p>JMM 规定了<strong>所有的变量都存储在主内存（Main Memory）中</strong>。</p><p>每条线程还有自己的<strong>工作内存（Working Memory），工作内存中保留了该线程使用到的变量的主内存的副本</strong>。工作内存是 JMM 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p><img src="'+B+'" alt="image-20231003081754493"></p><p>线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</p><blockquote><p>注意：为了获得较好的执行效能，</p><p>1、JMM 并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，</p><p>2、JMM 也没有限制即时编译器调整指令执行顺序这类优化措施</p></blockquote><h5 id="jmm解决什么问题" tabindex="-1"><a class="header-anchor" href="#jmm解决什么问题"><span>JMM解决什么问题？</span></a></h5><p>1、工作内存数据一致性：可见性问题</p><p>各个线程操作数据时会使用工作内存中的主内存中共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，可能导致各自的共享变量副本不一致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？</p><p>Java 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。</p><p>2、约束指令重排序优化：有序性问题</p><p>Java 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序可分为两类：编译期重排序和运行期重排序(处理器乱序优化)，分别对应编译时和运行时环境。</p><p>同样的，指令重排序不是随意重排序，它需要满足以下几个条件：</p><ul><li>在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 <code>as-if-serial</code> 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即使经过重排序后的执行结果要与顺序执行的结果保持一致。</li><li>存在数据依赖关系的不允许重排序。</li><li>多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。</li></ul><h5 id="jmm内存交互" tabindex="-1"><a class="header-anchor" href="#jmm内存交互"><span>JMM内存交互</span></a></h5><p>JMM 定义了 8 个操作来完成主内存和工作内存之间的交互操作。JVM 实现时必须保证下面介绍的每种操作都是 <strong>原子的</strong>（对于 double 和 long 型的变量来说，load、store、read、和 write 操作在某些平台上允许有例外 ）。</p><ul><li><code>lock</code> (锁定) - 作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态。</li><li><code>unlock</code> (解锁) - 作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><code>read</code> (读取) - 作用于<strong>主内存</strong>的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 <code>load</code> 动作使用。</li><li><code>load</code> (载入) - 作用于<strong>工作内存</strong>的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><code>use</code> (使用) - 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。</li><li><code>assign</code> (赋值) - 作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><code>store</code> (存储) - 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 <code>write</code> 操作使用。</li><li><code>write</code> (写入) - 作用于<strong>主内存</strong>的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存中复制到工作内存，就<strong>需要按序执行 <code>read</code> 和 <code>load</code> 操作</strong>；如果把变量从工作内存中同步回主内存中，就<strong>需要按序执行 <code>store</code> 和 <code>write</code> 操作</strong>。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p><p>JMM 还规定了上述 8 种基本操作，需要满足以下规则：</p><ol><li>read 和 load 必须成对出现**；**store 和 write 必须成对出现。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须把变化同步到主内存中。</li><li>不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign ）的变量。换句话说，就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 或 assign 操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。所以 lock 和 unlock 必须成对出现。</li><li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li><li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。</li><li>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）</li></ol><blockquote><p>注意：规则6，规则8需要大家留意一下！！！</p></blockquote><p>整体如下图所示：</p><p><img src="'+E+`" alt="image-20231003081758886"></p><h5 id="happens-before" tabindex="-1"><a class="header-anchor" href="#happens-before"><span>Happens-Before</span></a></h5><p>Java 内存模型里面，最晦涩的部分就是 Happens-Before 规则了，Happens-Before 规则最初是在一篇叫做 <a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf" target="_blank" rel="noopener noreferrer">Time, Clocks, and the Ordering of Events in a Distributed System</a> 的论文中提出来的，在这篇论文中，Happens-Before 的语义是一种因果关系。</p><p>如何来理解Happens-Before呢？如果就字面意思的话网上很多文章都翻译称：先行发生，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：<strong>前面一个操作的结果对后续操作是可见的</strong>。</p><blockquote><p>打个比方：A Happens-Before B，可表明A操作的结果对B是可见的。</p></blockquote><p>另外：Happens-Before有一个特性就是<strong>传递性</strong>：即 A Happens-Before B，B Happens-Before C，则 A Happens-Before C .</p><p>Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则，具体的一些规则如下：</p><p><strong>1、程序的顺序性规则</strong></p><p>这条规则是指在一个线程中，按照程序顺序（可能是重排序后的顺序），前面的操作 Happens-Before 于后续的任意操作，程序前面对某个变量的修改一定是对后续操作可见的</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ClassReordering {</span></span>
<span class="line"><span>    int x = 0, y = 0;</span></span>
<span class="line"><span>    public void writer() {</span></span>
<span class="line"><span>        x = 1;</span></span>
<span class="line"><span>        y = 2;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    public void reader() {</span></span>
<span class="line"><span>        int r1 = y;</span></span>
<span class="line"><span>        int r2 = x;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、volatile 变量规则</strong></p><p>这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。比如下方代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>class VolatileExample {</span></span>
<span class="line"><span>  int x = 0;</span></span>
<span class="line"><span>  volatile boolean v = false;</span></span>
<span class="line"><span>    // 线程A 先</span></span>
<span class="line"><span>  public void writer() {</span></span>
<span class="line"><span>    x = 42;</span></span>
<span class="line"><span>    v = true;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>    // 线程B 后</span></span>
<span class="line"><span>  public void reader() {</span></span>
<span class="line"><span>    if (v == true) {</span></span>
<span class="line"><span>      // 这里x会是多少呢？</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：</p><p>1、我们声明一个 volatile 变量 volatile int x = 0，它表达的是：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入</p><p>2、volatile 可以用来解决可见性问题</p></blockquote><p>这里有两点：</p><p>线程B能看到线程A对变量v的写结果</p><p>结合顺序性规则和传递性特性可知在线程B中仍然能得到x的值为42</p><blockquote><p>注意：第二点只有从jdk1.5开始才能满足，因为Java 内存模型在 1.5 版本对 volatile 语义进行了增强（禁止指令重排），1.5以前有可能x的值还为0。</p></blockquote><p><strong>3、管程中锁的规则</strong></p><p>对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p>当然这里需要先大致了解一下什么是管程：</p><p>管程（Monitors，也称为监视器），是一种通用的同步原语，能够实现对共享资源的互斥访问，Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。</p><p>管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>int x = 10;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void syn() {</span></span>
<span class="line"><span>    synchronized (this) { //此处自动加锁</span></span>
<span class="line"><span>      if (this.x &lt; 12) {</span></span>
<span class="line"><span>        this.x = 12; </span></span>
<span class="line"><span>      }  </span></span>
<span class="line"><span>    } //此处自动解锁</span></span>
<span class="line"><span>  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这个规则我们可以得出，释放锁之后，同步代码块中的操作结果对后续加锁时是可见的。同时结合前面讲的JMM内存操作可知，unlock时会将变量从工作内存刷到主内存中，获取锁时会从主内存中去读取变量值到工作内存中，也能证明锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p><strong>4、线程启动规则</strong></p><p>它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static int var = 66;</span></span>
<span class="line"><span>// 主线程A</span></span>
<span class="line"><span>public static void t1() {</span></span>
<span class="line"><span>    Thread B = new Thread(()-&gt;{</span></span>
<span class="line"><span>      // 主线程调用B.start()之前</span></span>
<span class="line"><span>      // 所有对共享变量的修改，此处皆可见</span></span>
<span class="line"><span>      // 此例中，var==77</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    // 此处对共享变量var修改</span></span>
<span class="line"><span>    var = 77;</span></span>
<span class="line"><span>    // 主线程启动子线程</span></span>
<span class="line"><span>    B.start();</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5、线程join规则</strong></p><p>它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作结果可见。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static int var = 55;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//主线程A</span></span>
<span class="line"><span>public static void t1() {</span></span>
<span class="line"><span>    Thread B = new Thread(()-&gt;{</span></span>
<span class="line"><span>      // 此处对共享变量var修改</span></span>
<span class="line"><span>      var = 66;</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 主线程启动子线程</span></span>
<span class="line"><span>    B.start();</span></span>
<span class="line"><span>    //主线程等待子线程B结束</span></span>
<span class="line"><span>    B.join()</span></span>
<span class="line"><span>    // 子线程所有对共享变量的修改</span></span>
<span class="line"><span>    // 在主线程调用B.join()之后皆可见</span></span>
<span class="line"><span>    // 此例中，var==66</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>6、线程中断规则</strong></p><p>对线程<code>interrupt()</code>方法的调用 Happens-Before 被中断线程的代码检测到中断事件的发生，比如我们可以通过<code>Thread.interrupted()/isInterrupted</code>方法检测到是否有中断发生。</p><p><strong>7、对象终结规则</strong></p><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p><h4 id="_2-2-5、volatile" tabindex="-1"><a class="header-anchor" href="#_2-2-5、volatile"><span>2.2.5、volatile</span></a></h4><p>volatile 是 JVM 提供的 <strong>最轻量级的同步机制</strong>，中文意思是不稳定的，易变的，用 <code>volatile</code> 修饰变量是为了保证变量在多线程中的可见性，它表达的含义是：告诉编译器，对这个变量的读写，需要基于主内存保证多CPU的缓存一致性。</p><p>volatile 变量的两个特性：<strong>解决可见性和有序性</strong></p><ul><li><p>保证变量对所有线程的可见性：当一条线程修改了 volatile 变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点</p><p>线程写 volatile 变量的过程：</p><ol><li>改变线程工作内存中 volatile 变量副本的值</li><li>将改变后的副本的值立即从工作内存刷新到主内存</li></ol><p>线程读 volatile 变量的过程：</p><ol><li>从主内存中读取 volatile 变量的最新值到线程的工作内存中</li><li>从工作内存中读取 volatile 变量的副本</li></ol><p><img src="`+C+`" alt="image-20231003081804285"></p><p>代码实例：</p></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 多线程共享变量 使用volatile保障可见性</span></span>
<span class="line"><span>private  static volatile boolean running =  true;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>private static void t1() throws InterruptedException {</span></span>
<span class="line"><span>    new Thread(()-&gt;{</span></span>
<span class="line"><span>        while (running) {</span></span>
<span class="line"><span>            //System.out.println(&quot;eat eat eat &quot;);</span></span>
<span class="line"><span>            //ThreadUtil.sleepSeconds(1);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        System.out.println(&quot;thread exit&quot;);</span></span>
<span class="line"><span>    }).start();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    TimeUnit.SECONDS.sleep(5);</span></span>
<span class="line"><span>    running = false;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：</p><p>1、volatile并不能保证并发操作的原子性，即不保证线程安全</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// volatile 能保障可见性但是无法保障原子性，线程安全无法保障</span></span>
<span class="line"><span>private static volatile int count = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public static void t2() throws InterruptedException {</span></span>
<span class="line"><span>    Thread t1 = new Thread(() -&gt; {</span></span>
<span class="line"><span>        for (int i = 0; i &lt; 50000; i++) {</span></span>
<span class="line"><span>            count++;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Thread t2 = new Thread(() -&gt; {</span></span>
<span class="line"><span>        for (int i = 0; i &lt; 50000; i++) {</span></span>
<span class="line"><span>            count++;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    //启动两个线程</span></span>
<span class="line"><span>    t1.start();</span></span>
<span class="line"><span>    t2.start();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //等待两个线程执行结束</span></span>
<span class="line"><span>    t1.join();</span></span>
<span class="line"><span>    t2.join();</span></span>
<span class="line"><span>    //输出count的最终结果</span></span>
<span class="line"><span>    System.out.println(&quot;count=&quot;+count);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可能在某一时刻，t1和t2 从主内存中读到了相同的count=100，然后经过工作内存操作之后均为101，t1和t2 将工作内存中的101刷到主内存，虽然刷新了2次但是最终的结果还是101。</p><p>2、volatile修饰引用类型，它只能保证引用本身的可见性，不能保证所引用对象内部属性的可见性</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static class A {</span></span>
<span class="line"><span>   /*volatile*/ boolean stop = false;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private  void t3() {</span></span>
<span class="line"><span>        while (!stop) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        System.out.println(&quot;program stopped&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// volatile 修饰引用类型，只能保证该引用是可见的，对于所引用对下的属性是不可见的</span></span>
<span class="line"><span>private static volatile A a = new A();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private static void t4() throws InterruptedException{</span></span>
<span class="line"><span>    new Thread(a::t3,&quot;t1&quot;).start();</span></span>
<span class="line"><span>    TimeUnit.SECONDS.sleep(5);</span></span>
<span class="line"><span>    a.stop = true;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>禁止进行指令重排序，具体一点解释，禁止重排序的规则如下：</p><ul><li>写<code>volatile</code>变量时，可以确保<code>volatile</code>写之前的操作不会被编译器重排序到<code>volatile</code>写之后。</li><li>读<code>volatile</code>变量时，可以确保<code>volatile</code>读之后的操作不会被编译器重排序到<code>volatile</code>读之前。</li></ul></li></ul><p>所以，单例模式的DCL写法需要使用volatile。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class Singleton {</span></span>
<span class="line"><span>  private Singleton(){}</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>  static volatile Singleton instance;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>  static Singleton getInstance(){</span></span>
<span class="line"><span>    if (instance == null) {</span></span>
<span class="line"><span>      synchronized(Singleton.class) {</span></span>
<span class="line"><span>        if (instance == null)</span></span>
<span class="line"><span>          instance = new Singleton();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return instance;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-6、synchronized" tabindex="-1"><a class="header-anchor" href="#_2-2-6、synchronized"><span>2.2.6、synchronized</span></a></h4><h5 id="锁概述" tabindex="-1"><a class="header-anchor" href="#锁概述"><span>锁概述</span></a></h5><p>通过前面我们知道发生原子性的根源是CPU在执行完任意指令后都有可能发生线程切换。如果能够禁用线程切换的话那这个问题也就迎刃而解了。操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。</p><blockquote><p>知识点：CPU中断</p><p>让CPU停下当前的工作任务，去处理其他事情，处理完后回来继续执行刚才的任务，这一过程便是中断。</p><p>可参考知乎文章：https://zhuanlan.zhihu.com/p/360548214</p></blockquote><p>当然这种方案在单核CPU是可行的，但是在多核CPU中就不行了，为什么？我们来分析一下</p><p>我们以在32位CPU上执行long 型变量的写操作为例：long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低 32 位，如下图所示）</p><p><img src="`+S+'" alt="image-20231003081809071"></p><p>在单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。</p><p>但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证某个CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现一些诡异 的Bug 了。</p><p>也就是说真正保证并发原子性的是：<strong>同一时刻只有一个线程执行</strong>，这个条件非常重要，我们<strong>称之为互斥</strong>。如果我们能够<strong>保证对共享变量的修改是互斥的</strong>，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。</p><p>在并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。</p><p>加锁是我们能想到的最直接也是最通用的互斥解决方案，加锁的模型如下图所示：</p><p><img src="'+x+`" alt="image-20231003081812439"></p><p>这里需要注意的地方:</p><p>1、就是锁和要保护资源之间的对应关系，图中虚线部分，很多时候就是忘记了这个关系从而导致了很多了问题</p><p>2、锁并不能并不能改变CPU时间片切换的特点，只是当其他线程要访问这个资源时，发现锁还未释放，所以只能等待。同时也说明线程切换是不会释放锁的。</p><h5 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h5><p>Java 语言提供的 synchronized 关键字，就是锁的一种实现。synchronized 关键字可以用来修饰方法，也可以用来修饰代码块，一般的用法如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static int i = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 1、修饰非静态方法</span></span>
<span class="line"><span>public synchronized void foo() {</span></span>
<span class="line"><span>    i++;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 2、修饰静态方法</span></span>
<span class="line"><span>public static synchronized void bar() {</span></span>
<span class="line"><span>    i--;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>Object obj = new Object();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void car() {</span></span>
<span class="line"><span>    //3、修饰代码块</span></span>
<span class="line"><span>    synchronized (obj) {</span></span>
<span class="line"><span>        i+=2;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>public static void main(String[] args) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>回顾前面讲的互斥锁模型，结合我们的代码，有几个要注意的问题：</p><p>1、加锁和解锁操作在哪里体现的？</p><p>synchronized 的加锁和解锁是隐式实现的，可以查看字节码</p><p>2、synchronized 的锁对象是什么，也就是说锁定的是哪个对象？</p><ul><li>如果修饰的是代码块，锁对象是我们自己指定的，指定哪个对象就锁定哪个对象。</li><li>如果修饰的是非静态方法，锁定的是当前实例对象 <code>this</code>。</li><li>如果修饰的是静态方法，锁定的是当前类的 Class 对象。</li></ul><p>再来看如下代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static class AddOneProblem {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    long i = 0L;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     *  我们知道：i+=1 并非原子操作，会有线程安全问题</span></span>
<span class="line"><span>     *  要想得以解决就可以加锁</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public synchronized void addOne() {</span></span>
<span class="line"><span>        i+=1;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于<code>addOne</code>方法，添加了<code>synchronized</code>修饰之后，无论是单核 CPU 还是多核 CPU，只有一个线程能够执行 addOne() 方法，所以一定能保证原子操作。</p><p>至于可见性，前面提到的<code>Happens-Before</code>规则中有一条管程中的锁规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁，再结合Happens-Before 的传递性原则，我们知道，<code>addOne</code>方法中+1操作的结果肯定会在释放锁之前刷到主内存，锁释放后下一个进入到<code>addOne</code>方法的线程获取锁时能够获取到上一个线程的操作结果。即前一个线程在临界区修改的共享变量，对后续进入临界区的线程是可见的。</p><p>另外：也体现出synchronized 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。</p><p>执行解锁操作时会将工作内存中的共享变量刷到主内存（参考JMM中的<code>unlock</code>）。</p><p>执行加锁操作时会清空工作内存中共享变量副本的值，需要使用时从主内存重新加载（参考JMM中的<code>lock</code>）。</p><p>但是要注意的是：使用锁来保证可见性太笨重，因为<code>synchronized</code>是线程独占的，其他线程会被阻塞，这里面还存在一些线程调度开销，因为它是靠操作系统内核互斥锁实现的。而<code>volatile</code>是相对轻量级的，但是<code>synchronized</code>除了保证可见性还能保证原子性，而<code>volatile</code>不能保证原子性。</p><h5 id="锁和资源的关系" tabindex="-1"><a class="header-anchor" href="#锁和资源的关系"><span>锁和资源的关系</span></a></h5><p>前面提到，受保护资源和锁之间的关联关系非常重要，他们的关系是怎样的呢？</p><p>一个合理的关系是：**锁和受保护资源之间的关联关系是 1：N 的关系。**如下图</p><p><img src="`+T+`" alt="image-20231003081818561"></p><p>但有时候我们写出的代码往往破坏了这个关系，我们举几个例子：</p><p><strong>1、多把锁保护同一个资源的情况 ：现实世界中可以，并发编程领域不行</strong>。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>class LR{</span></span>
<span class="line"><span>    static long i = 0L;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    synchronized void subOne() {</span></span>
<span class="line"><span>        i-=1;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    static synchronized void addOne() {</span></span>
<span class="line"><span>        i+=1;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码是用两个锁保护一个资源。这个受保护的资源就是静态变量 <code>i</code>，两个锁分别是 \`\`this<code>和 </code>LR.class<code>。我们可以用下面这幅图来形象描述这个关系。由于临界区 subOne() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 addOne() 对 变量</code>i\`的修改对临界区 subOne() 也没有可见性保证，这就导致并发问题了。</p><p><img src="`+w+`" alt="image-20231003081823000"></p><p><strong>2、一把锁如何保护多个资源</strong></p><p>一把锁可以保护多个资源，但是这里就涉及到一个<strong>锁粒度</strong>的问题。需要仔细把握，掌握的不好就会造成问题。</p><h5 id="linux内核同步机制" tabindex="-1"><a class="header-anchor" href="#linux内核同步机制"><span>Linux内核同步机制</span></a></h5><p>POSIX threads(简称pthreads)是<a href="https://baike.baidu.com/item/POSIX" target="_blank" rel="noopener noreferrer">POSIX</a>的线程标准，定义了创建和操纵线程的一套<a href="https://baike.baidu.com/item/API" target="_blank" rel="noopener noreferrer">API</a>I，我们需要的互斥机制就是用pthreads提供的锁机制(lock)来对多个线程之间共 享的临界区(Critical Section)进行保护。</p><p>pthreads提供的锁机制如下：</p><p>1、Mutex（互斥量）：<strong>pthread_mutex_t</strong>，通过对该结构的操作，来判断资源是否可以访问，Mutex属于sleep-waiting类型的锁，例如在多核机器上有两个线程A，B，如果此时锁被A持有，那么B就会被阻塞，在等待队列中等待。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>man -k mutex</span></span>
<span class="line"><span></span></span>
<span class="line"><span>pthread_mutex_consistent (3p) - mark state protected by robust mutex as consistent</span></span>
<span class="line"><span>pthread_mutex_destroy (3p) - destroy and initialize a mutex</span></span>
<span class="line"><span>pthread_mutex_getprioceiling (3p) - get and set the priority ceiling of a mutex (REALTIME THREADS)</span></span>
<span class="line"><span>pthread_mutex_init (3p) - destroy and initialize a mutex</span></span>
<span class="line"><span>pthread_mutex_lock (3p) - lock and unlock a mutex</span></span>
<span class="line"><span>pthread_mutex_setprioceiling (3p) - get and set the priority ceiling of a mutex (REALTIME THREADS)</span></span>
<span class="line"><span>pthread_mutex_timedlock (3p) - lock a mutex (ADVANCED REALTIME)</span></span>
<span class="line"><span>pthread_mutex_trylock (3p) - lock and unlock a mutex</span></span>
<span class="line"><span>pthread_mutex_unlock (3p) - lock and unlock a mutex</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、Spin lock（自旋锁）：<strong>pthread_spinlock_t</strong>，属于busy-waiting类型的锁，它不会引起调用者睡眠等待，如果获取不到锁则进入忙等待，它会不停的尝试去获取锁，俗称自旋，获取锁的性能相对较高，但是费CPU，所以自旋锁不应该被长时间的持有。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>man -k spin</span></span>
<span class="line"><span></span></span>
<span class="line"><span>pthread_spin_destroy (3p) - destroy or initialize a spin lock object (ADVANCED REALTIME THREADS)</span></span>
<span class="line"><span>pthread_spin_init (3p) - destroy or initialize a spin lock object (ADVANCED REALTIME THREADS)</span></span>
<span class="line"><span>pthread_spin_lock (3p) - lock a spin lock object (ADVANCED REALTIME THREADS)</span></span>
<span class="line"><span>pthread_spin_trylock (3p) - lock a spin lock object (ADVANCED REALTIME THREADS)</span></span>
<span class="line"><span>pthread_spin_unlock (3p) - unlock a spin lock object (ADVANCED REALTIME THREADS)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、 Condition Variable（条件变量）：<strong>pthread_cond_t</strong>，条件变量是利用线程间共享的全局变量，进行同步的一种机制</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>man -k cond</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>4、Read/Write Lock（读写锁）：<strong>pthread_rwlock_t</strong>，读写锁是用来解决读多写少问题的，读操作可以共享，写操作是排他的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>man -k rwlock</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>另外内核还提供了信号量(semaphore)机制，也可用于互斥锁的实现</p><p>5、semaphore：<strong>sem_t</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>man -k sem</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>下面从不同的层面来认识synchronized关键字的底层实现。</p><h5 id="synchronized源码层面" tabindex="-1"><a class="header-anchor" href="#synchronized源码层面"><span>synchronized源码层面</span></a></h5><p>源码层面是最好理解的，代码如下，这里不再赘述</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public static void synClass() {</span></span>
<span class="line"><span>    Object obj = new Object();</span></span>
<span class="line"><span>    synchronized (obj) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="synchronized字节码层面" tabindex="-1"><a class="header-anchor" href="#synchronized字节码层面"><span>synchronized字节码层面</span></a></h5><p>下面我们来看一看上面的代码生成的字节码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span> 0 new #2 &lt;java/lang/Object&gt;</span></span>
<span class="line"><span> 3 dup</span></span>
<span class="line"><span> 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;</span></span>
<span class="line"><span> 7 astore_1</span></span>
<span class="line"><span> 8 aload_1</span></span>
<span class="line"><span> 9 dup</span></span>
<span class="line"><span>10 astore_2</span></span>
<span class="line"><span>11 monitorenter</span></span>
<span class="line"><span>12 aload_2</span></span>
<span class="line"><span>13 monitorexit</span></span>
<span class="line"><span>14 goto 22 (+8)</span></span>
<span class="line"><span>17 astore_3</span></span>
<span class="line"><span>18 aload_2</span></span>
<span class="line"><span>19 monitorexit</span></span>
<span class="line"><span>20 aload_3</span></span>
<span class="line"><span>21 athrow</span></span>
<span class="line"><span>22 return</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中跟synchronized关键字相关的就是这样的字节码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>monitorenter</span></span>
<span class="line"><span>........</span></span>
<span class="line"><span>monitorexit</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>monitorenter主要是获取监视器锁，monitorexit主要是释放监视器锁</p><h5 id="synchronized-jvm层面" tabindex="-1"><a class="header-anchor" href="#synchronized-jvm层面"><span>synchronized jvm层面</span></a></h5><p>如果一旦获取了某个对象的锁，我们来看一下，获取到对象锁前后该对象有什么变化</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public static void synJvm() {</span></span>
<span class="line"><span>    Object obj = new Object();</span></span>
<span class="line"><span>    System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span>    synchronized (obj) {</span></span>
<span class="line"><span>        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用JOL打印对象的内存结构，添加如下依赖：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span>
<span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;0.9&lt;/version&gt;</span></span>
<span class="line"><span>    &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打印输出的结果如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>java.lang.Object object internals:</span></span>
<span class="line"><span> OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span></span>
<span class="line"><span>      0     4    (object header)  01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span></span>
<span class="line"><span>      4     4    (object header)  00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span></span>
<span class="line"><span>      8     4    (object header)  e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span></span>
<span class="line"><span>     12     4    (loss due to the next object alignment)</span></span>
<span class="line"><span>Instance size: 16 bytes</span></span>
<span class="line"><span>Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span>
<span class="line"><span></span></span>
<span class="line"><span>java.lang.Object object internals:</span></span>
<span class="line"><span> OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span></span>
<span class="line"><span>      0     4    (object header)  58 f3 2f 92 (01011000 11110011 00101111 10010010) (-1842351272)</span></span>
<span class="line"><span>      4     4    (object header)  a3 00 00 00 (10100011 00000000 00000000 00000000) (163)</span></span>
<span class="line"><span>      8     4    (object header)  e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span></span>
<span class="line"><span>     12     4    (loss due to the next object alignment)</span></span>
<span class="line"><span>Instance size: 16 bytes</span></span>
<span class="line"><span>Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在锁的使用过程中伴随着一系列的锁升级过程。</p><h5 id="markword" tabindex="-1"><a class="header-anchor" href="#markword"><span>markword</span></a></h5><p>通过打印一个Object对象加锁前后内存布局的变化可知，对一个对象使用synchronized关键字加锁，锁信息是存储在对象头markword中的。我们可以从JVM源码中找到关于对象头markword的说明</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>src\\share\\vm\\oops\\markOop.hpp</span></span>
<span class="line"><span>//  64 bits:</span></span>
<span class="line"><span>//  --------</span></span>
<span class="line"><span>//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span>
<span class="line"><span>//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span>
<span class="line"><span>//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span>
<span class="line"><span>//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span>
<span class="line"><span>//</span></span>
<span class="line"><span>//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span>
<span class="line"><span>//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span>
<span class="line"><span>//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span>
<span class="line"><span>//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>markword图示如下：</p><p><img src="`+_+'" alt="image-20231003081829773"></p><p>我们发现，markword的后三位被设定成了跟锁相关的标志位，其中有两位是锁标志位，1位是偏向锁标志位。</p><h5 id="锁升级" tabindex="-1"><a class="header-anchor" href="#锁升级"><span>锁升级</span></a></h5><p>前面我们看到了synchronized在字节码层面是对应<code>monitorenter</code>合<code>monitorexit</code>，而真正实现互斥的锁其实依赖操作系统底层的<code>Mutex Lock</code>来实现，首先要明确一点，这个锁是一个重量级的锁，由操作系统直接管理，要想使用它，需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。</p><p><img src="'+q+'" alt="image-20231003081833573"></p><p>确实jdk1.6之前每次获取的都是重量级锁，无疑在很多场景下性能不高，故jdk1.6对synchronized做了很大程度的优化，其目的就是为了减少这种重量级锁的使用。</p><p>整体锁升级的过程大致可以分为两条路径，如下：</p><p><img src="'+j+`" alt="image-20231003081836936"></p><p>1、偏向锁未启动，默认轻量级锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 未使用过锁的状态</span></span>
<span class="line"><span>public static void noSyn() throws InterruptedException {</span></span>
<span class="line"><span>    Object obj = new Object();</span></span>
<span class="line"><span>    System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span>    //如果调用了hashcode</span></span>
<span class="line"><span>    int hashCode = obj.hashCode();</span></span>
<span class="line"><span>    System.out.println(&quot;调用hashcode&quot;);</span></span>
<span class="line"><span>    System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span>    System.out.println(&quot;尝试加锁&quot;);</span></span>
<span class="line"><span>    //使用synchronized</span></span>
<span class="line"><span>    synchronized (obj) {</span></span>
<span class="line"><span>        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    System.out.println(&quot;退出锁,查看一下&quot;);</span></span>
<span class="line"><span>    //退出锁 查看obj</span></span>
<span class="line"><span>    System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span>    System.out.println(&quot;开始有竞争了&quot;);</span></span>
<span class="line"><span>    // 竞争一下子</span></span>
<span class="line"><span>    for (int i=0;i&lt;2;i++) {</span></span>
<span class="line"><span>        new Thread(()-&gt;{</span></span>
<span class="line"><span>            synchronized (obj) {</span></span>
<span class="line"><span>                System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }).start();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    TimeUnit.SECONDS.sleep(2);</span></span>
<span class="line"><span>    System.out.println(&quot;退出竞争了&quot;);</span></span>
<span class="line"><span>    System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>轻量级锁：线程在自己的线程栈生成<code>Lock Record</code>，使用CAS的方式将markword设置为指向自己线程<code>LOCK Record</code>的指针，设置成功者得锁。竞争会让锁膨胀为重量级锁。</p><p>2、偏向锁启动</p><p>偏向锁，偏向的是第一个来获取锁的线程。所谓上偏向锁，指的是获取锁的线程在markword中写自己的线程ID的过程，偏向锁升级为轻量级锁时首先要撤销偏向锁，如何设置轻量级锁。</p><p>偏向锁默认是打开的，但是启动有一个时延，默认4s，之所以要延迟，是因为JVM虚拟机自己有一些默认的启动线程，里面有好多sync代码，这些代码启动时就肯定会有竞争，如果直接使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>static void biasebdLocking() throws InterruptedException {</span></span>
<span class="line"><span>        Thread.sleep(5000);//或开启-XX:BiasedLockingStartupDelay=0</span></span>
<span class="line"><span>         System.out.println(&quot;等待偏向锁启动&quot;);</span></span>
<span class="line"><span>        Object o = new Object();</span></span>
<span class="line"><span>         System.out.println(ClassLayout.parseInstance(o).toPrintable());//偏向状态正常开启</span></span>
<span class="line"><span>         System.out.println(&quot;开始获取锁&quot;);</span></span>
<span class="line"><span>        synchronized (o){</span></span>
<span class="line"><span>            //偏向锁执行</span></span>
<span class="line"><span>            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        //代码块已退出</span></span>
<span class="line"><span>        System.out.println(&quot;锁释放&quot;);</span></span>
<span class="line"><span>        //再次打印对象 o 的 markword 可以看出对象依然是偏向状态 Thread ID被设置为主线程</span></span>
<span class="line"><span>         System.out.println(ClassLayout.parseInstance(o).toPrintable());</span></span>
<span class="line"><span>         System.out.println(&quot;再开一个线程获取锁&quot;);</span></span>
<span class="line"><span>         new Thread(()-&gt;{</span></span>
<span class="line"><span>             synchronized (o){</span></span>
<span class="line"><span>                 System.out.println(ClassLayout.parseInstance(o).toPrintable());//我们可以看到偏向被撤销</span></span>
<span class="line"><span>             }</span></span>
<span class="line"><span>         }).start();</span></span>
<span class="line"><span>         TimeUnit.SECONDS.sleep(1);</span></span>
<span class="line"><span>         System.out.println(&quot;锁释放&quot;);</span></span>
<span class="line"><span>         System.out.println(ClassLayout.parseInstance(o).toPrintable());</span></span>
<span class="line"><span>         System.out.println(&quot;有竞争&quot;);</span></span>
<span class="line"><span>        //开启子线程</span></span>
<span class="line"><span>         for (int i=0;i&lt;2;i++) {</span></span>
<span class="line"><span>             new Thread(()-&gt;{</span></span>
<span class="line"><span>                 synchronized (o){</span></span>
<span class="line"><span>                     System.out.println(ClassLayout.parseInstance(o).toPrintable());//我们可以看到偏向被撤销</span></span>
<span class="line"><span>                 }</span></span>
<span class="line"><span>             }).start();</span></span>
<span class="line"><span>         }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Thread.sleep(1000);</span></span>
<span class="line"><span>         System.out.println(&quot;锁被释放&quot;);</span></span>
<span class="line"><span>        //我们再次查看对象 o 的mark word 偏向被撤销（无锁状态）</span></span>
<span class="line"><span>         System.out.println(ClassLayout.parseInstance(o).toPrintable());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>markword后三位：1 01</p><p>细心的你也许会发现，还未加锁时，对象的锁状态位就已经是 101了，的确，偏向锁一旦启动后，这时候New出来的对象就是匿名偏向锁对象 ，就是说他已经就是偏向锁了，但是没有线程ID，里面空的。有线程来抢，将自己的ID贴出来，就是偏向锁。</p><p>另外注意：如果已启动偏向锁，但是加锁前调用了hashcode，则无法使用偏向锁 原因是markword中存了hashcode后没位置存偏向锁线程id了，加锁时直接就是轻量级锁了。</p><p>另外：有锁升级，是不是也有锁降级呢？</p><p>https://www.zhihu.com/question/63859501</p><p>STW</p><h5 id="锁消除-锁粗化" tabindex="-1"><a class="header-anchor" href="#锁消除-锁粗化"><span>锁消除，锁粗化</span></a></h5><p>锁消除（lock eliminate）：虚拟机的运行时编译器在运行时如果检测到一些要求同步的代码上不可能发生共享数据竞争，则会去掉这些锁。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 锁消除 append方法本身是添加了synchronized的，但sb变量是线程私有的不会发生竞争</span></span>
<span class="line"><span>public static void lockEliminate() {</span></span>
<span class="line"><span>    StringBuffer sb = new StringBuffer();</span></span>
<span class="line"><span>    sb.append(&quot;hello&quot;).append(&quot;ts&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>锁粗化（Lock coarsening）：将临近的代码块用同一个锁合并起来。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 锁粗化</span></span>
<span class="line"><span>public static String lockCoarsening() {</span></span>
<span class="line"><span>    int i=0;</span></span>
<span class="line"><span>    StringBuffer sb = new StringBuffer();</span></span>
<span class="line"><span>    while (i&lt;100) {</span></span>
<span class="line"><span>        sb.append(i);</span></span>
<span class="line"><span>        i++;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return sb.toString();</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="一些经验" tabindex="-1"><a class="header-anchor" href="#一些经验"><span>一些经验</span></a></h5><ul><li><p>降低锁的等级</p><p>能用对象级别的，尽量别用类锁，能用实例变量的不要用静态变量</p></li><li><p>减少锁的时间 不需要同步执行的代码，能不放在同步块里面执行就不要放在同步快内，可以让锁尽快释放</p></li><li><p>减少锁的粒度 共享资源数决定锁的数量。有一组资源定义一把锁，而不是多组资源共用一把锁，增加并行度，从而降低锁竞争，典型如分段锁</p></li><li><p>减少加减锁的次数 假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都要加锁</p></li><li><p>读写锁 业务细分，读操作加读锁，可以并发读，写操作使用写锁</p></li><li><p>善用volatile</p><p>volatile的控制比synchronized更轻量化，在某些变量上不涉及多步打包操作和原子性问题，可以加以运用。</p><p>如ConcurrentHashMap的get操作，使用的volatile而不是加锁</p></li></ul><h3 id="_2-3-threadlocal" tabindex="-1"><a class="header-anchor" href="#_2-3-threadlocal"><span>2.3 ThreadLocal</span></a></h3><h4 id="_2-3-1-概念" tabindex="-1"><a class="header-anchor" href="#_2-3-1-概念"><span>2.3.1 概念</span></a></h4><p>​ ThreadLocal类并不是用来解决多线程环境下的共享变量问题，而是用来提供线程内部的独享变量。在多线程环境下，可以保证各个线程之间的变量互相隔离、相互独立。</p><h4 id="_2-3-2-使用" tabindex="-1"><a class="header-anchor" href="#_2-3-2-使用"><span>2.3.2 使用</span></a></h4><p>​ ThreadLocal实例一般定义为private static类型的，在一个线程内，该变量共享一份，类似上下文作用，可以用来上下传递信息。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public class App {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private static ThreadLocal&lt;App&gt; threadLocal = new ThreadLocal&lt;&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) throws InterruptedException {</span></span>
<span class="line"><span>        Thread t1 = new Thread(() -&gt; {</span></span>
<span class="line"><span>            threadLocal.set(new App());</span></span>
<span class="line"><span>            App app = threadLocal.get();</span></span>
<span class="line"><span>            System.out.println(Thread.currentThread().getName()+&quot;---&quot;+app);</span></span>
<span class="line"><span>        },&quot;t1&quot;);</span></span>
<span class="line"><span>        Thread t2 = new Thread(() -&gt; {</span></span>
<span class="line"><span>            App app = threadLocal.get();</span></span>
<span class="line"><span>            System.out.println(Thread.currentThread().getName()+&quot;---&quot;+app);</span></span>
<span class="line"><span>        },&quot;t2&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        t1.start();</span></span>
<span class="line"><span>        t1.join();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        t2.start();</span></span>
<span class="line"><span>        t2.join();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-3-3-应用场景" tabindex="-1"><a class="header-anchor" href="#_2-3-3-应用场景"><span>2.3.3 应用场景</span></a></h4><ul><li>数据库连接</li><li>下面的基于日志平台的访问链路追踪中，会用到</li><li>上下文传递参数</li></ul><h4 id="_2-3-4-实现原理" tabindex="-1"><a class="header-anchor" href="#_2-3-4-实现原理"><span>2.3.4 实现原理</span></a></h4><p>​ 先明白类关系：</p><ul><li>Thread，ThreadLocal是两个独立的类</li><li>在Thread中有个属性叫threadLocals，它的类型是ThreadLocalMap</li><li>ThreadLocalMap是一个内部类，在ThreadLocal里…… 😓</li></ul><p>​ 这个存储结构的思路是反转的....</p><p><img src="`+F+`" alt="image-20200706155313157"></p><p>1）set方法源码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public void set(T value) {</span></span>
<span class="line"><span>    //取到当前线程</span></span>
<span class="line"><span>    Thread t = Thread.currentThread();</span></span>
<span class="line"><span>    //从当前线程中拿出Map</span></span>
<span class="line"><span>    ThreadLocalMap map = getMap(t);</span></span>
<span class="line"><span>    if (map != null)</span></span>
<span class="line"><span>        //如果非空，说明之前创建过了</span></span>
<span class="line"><span>        //以当前创建的ThreadLocal对象为key，需要存储的值为value，写入Map</span></span>
<span class="line"><span>        //因为每个线程Thread里有自己独自的Map，所以起到了隔离作用</span></span>
<span class="line"><span>        map.set(this, value);</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        //如果没有，那就创建</span></span>
<span class="line"><span>        createMap(t, value);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）get方法源码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public T get() {</span></span>
<span class="line"><span>    Thread t = Thread.currentThread();</span></span>
<span class="line"><span>    //获取到当前线程下的Map</span></span>
<span class="line"><span>    ThreadLocalMap map = getMap(t);</span></span>
<span class="line"><span>    if (map != null) {</span></span>
<span class="line"><span>        //如果非空，根据当前ThreadLocal为key，取出对应的value即可</span></span>
<span class="line"><span>        ThreadLocalMap.Entry e = map.getEntry(this);</span></span>
<span class="line"><span>        if (e != null) {</span></span>
<span class="line"><span>            @SuppressWarnings(&quot;unchecked&quot;)</span></span>
<span class="line"><span>            T result = (T)e.value;</span></span>
<span class="line"><span>            return result;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    //如果map是空的，往往返回一个初始值，这是一个protect方法</span></span>
<span class="line"><span>    //这就是为什么创建ThreadLocal的时候往往要求实现这个方法</span></span>
<span class="line"><span>    return setInitialValue();</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）remove方法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>public void remove() {</span></span>
<span class="line"><span>    ThreadLocalMap m = getMap(Thread.currentThread());</span></span>
<span class="line"><span>    //很简单，获取到map后，调用remove移除掉</span></span>
<span class="line"><span>    if (m != null)</span></span>
<span class="line"><span>        m.remove(this);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4）内存泄露问题如何解决</p><p>​ 在上述的get方法中，Entry类继承了WeakReference，即每个Entry对象都有一个ThreadLocal的弱引用，GC对于弱引用的对象采取积极的内存回收策略，避免无人搭理时发生内存泄露。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ThreadLocalMap.Entry e = map.getEntry(this);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="`+P+`" alt="image-20200706160910377"></p><p>验证代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>ThreadLocal local = new ThreadLocal();</span></span>
<span class="line"><span>local.set(100);</span></span>
<span class="line"><span>System.out.println(local.get());</span></span>
<span class="line"><span>System.gc();</span></span>
<span class="line"><span>//不会回收，因为local被强引用</span></span>
<span class="line"><span>System.out.println(local.get());</span></span>
<span class="line"><span>local = null;</span></span>
<span class="line"><span>//debug，查看currentThread里面的localMaps</span></span>
<span class="line"><span>//注意table里的reference</span></span>
<span class="line"><span>Thread currentThread = Thread.currentThread();</span></span>
<span class="line"><span>//断点1：虽然local被赋值null，但是ThreadLocal内部依然存在引用（内存泄露风险！）</span></span>
<span class="line"><span>System.out.println(1);</span></span>
<span class="line"><span>System.gc();</span></span>
<span class="line"><span>//断点2：gc后，引用消失</span></span>
<span class="line"><span>System.out.println(2);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ ThreadLocal对象只是作为ThreadLocalMap的一个key而存在的，现在它被回收了，那么value呢？针对这一问题，ThreadLocalMap类在每次get()，set()，remove() ThreadLocalMap中的值的时候，会自动清理key为null的value。如此一来，value也能被回收了。</p><p>​ <em>用完ThreadLocal后，手动remove是一个好习惯！</em></p><p>​</p><h4 id="_2-3-5-注意" tabindex="-1"><a class="header-anchor" href="#_2-3-5-注意"><span>2.3.5 注意！</span></a></h4><p>ThreadLocal如果指向了同一个引用，会打破隔离而失效。</p><p>案例：隔离失败了！</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>package com.itheima.thread;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import java.util.HashMap;</span></span>
<span class="line"><span>import java.util.Map;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class BadLocal{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>         ThreadLocal&lt;Map&gt; local = new ThreadLocal();</span></span>
<span class="line"><span>        Map map = new HashMap();</span></span>
<span class="line"><span>        new Thread(()-&gt;{</span></span>
<span class="line"><span>            //在线程设置后，过段时间取name</span></span>
<span class="line"><span>            //猜一猜结果？</span></span>
<span class="line"><span>            map.put(&quot;name&quot;,&quot;i am &quot;+Thread.currentThread().getName());</span></span>
<span class="line"><span>            local.set(map);</span></span>
<span class="line"><span>            System.out.println(Thread.currentThread().getName()+&quot;:&quot;</span></span>
<span class="line"><span>                    +local.get().get(&quot;name&quot;));</span></span>
<span class="line"><span>            //do something...</span></span>
<span class="line"><span>            try {</span></span>
<span class="line"><span>                Thread.sleep(1000);</span></span>
<span class="line"><span>            } catch (InterruptedException e) {</span></span>
<span class="line"><span>                e.printStackTrace();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            System.out.println(Thread.currentThread().getName()+&quot;:&quot;</span></span>
<span class="line"><span>                    +local.get().get(&quot;name&quot;));</span></span>
<span class="line"><span>        },&quot;t1&quot;).start();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        new Thread(()-&gt;{</span></span>
<span class="line"><span>            //在线程中赋值name</span></span>
<span class="line"><span>            map.put(&quot;name&quot;,&quot;i am &quot;+Thread.currentThread().getName());</span></span>
<span class="line"><span>            local.set(map);</span></span>
<span class="line"><span>        },&quot;t2&quot;).start();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h1><h2 id="关于线程池任务管理-宕机了怎么处理没执行的线程" tabindex="-1"><a class="header-anchor" href="#关于线程池任务管理-宕机了怎么处理没执行的线程"><span>关于线程池任务管理,宕机了怎么处理没执行的线程</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>首先设计一张表,记录任务状态,执行时间,已执行,未执行等等</span></span>
<span class="line"><span>其次任务来的时候写入表中,任务标识未执行</span></span>
<span class="line"><span>如果此时有1000个任务都过来了,那么表中也有1000行记录</span></span>
<span class="line"><span>接着JVM内存溢出OOM,程序挂了,未执行的任务就知道是哪些了.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>系统再次启动的时候,依次读取未执行的任务加入线程池中复盘,二次执行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,551)]))}const M=n(z,[["render",L]]),U=JSON.parse('{"path":"/chuxin/07_%E6%96%B9%E5%90%91/06_%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/03_JUC/","title":"【深入代码系列】手牵手一起学JUC","lang":"zh-CN","frontmatter":{"typora-root-url":"../../../.vuepress/public","title":"【深入代码系列】手牵手一起学JUC","id":"code-deep-concurrency-juc.html","tags":["方向","并发","JUC"],"categories":["编程"],"keywords":"语法,基础,Java,微服务,编程,数据存储","description":"并发编程","date":"2024-11-13T11:47:53.000Z","createTime":"2025/08/23 15:49:32","permalink":"/chuxin/07_方向/06_并发编程/03_JUC/","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【深入代码系列】手牵手一起学JUC\\",\\"image\\":[\\"https://zuoer96.github.io/docs/docs/images/u=128634482,3004766485&fm=26&gp=0.jpg\\",\\"https://zuoer96.github.io/docs/docs/images/image-20210223151838104.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081944836.png\\",\\"https://zuoer96.github.io/docs/docs/images/threadpoolexecutor.jpg\\",\\"https://zuoer96.github.io/docs/docs/images/image-20200630181602123.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081954830.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20200716083708939.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20200716083953114.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20200714164029991.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081920956.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081934377.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081853814.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081858204.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081733471.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081737647.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081741216.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081747028.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081751201.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081754493.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081758886.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081804285.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081809071.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081812439.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081818561.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081823000.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081829773.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081833573.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20231003081836936.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20200706155313157.png\\",\\"https://zuoer96.github.io/docs/docs/images/image-20200706160910377.png\\"],\\"datePublished\\":\\"2024-11-13T11:47:53.000Z\\",\\"dateModified\\":\\"2025-09-03T02:00:28.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://zuoer96.github.io/docs/docs/chuxin/07_%E6%96%B9%E5%90%91/06_%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/03_JUC/"}],["meta",{"property":"og:site_name","content":"编程备忘录"}],["meta",{"property":"og:title","content":"【深入代码系列】手牵手一起学JUC"}],["meta",{"property":"og:description","content":"并发编程"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://zuoer96.github.io/docs/docs/images/u=128634482,3004766485&fm=26&gp=0.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-03T02:00:28.000Z"}],["meta",{"property":"article:tag","content":"JUC"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:tag","content":"方向"}],["meta",{"property":"article:published_time","content":"2024-11-13T11:47:53.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-03T02:00:28.000Z"}]]},"readingTime":{"minutes":70.82,"words":21247},"git":{"createdTime":1755938647000,"updatedTime":1756864828000,"contributors":[{"name":"zuoer96","username":"zuoer96","email":"31268184+zuoer96@users.noreply.github.com","commits":3,"avatar":"https://avatars.githubusercontent.com/zuoer96?v=4","url":"https://github.com/zuoer96"}]},"filePathRelative":"notes/00-方向/06_并发编程/03_JUC.md","headers":[],"bulletin":true}');export{M as comp,U as data};
